<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GodotBook</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="doc/demo01_hello/download.html">Download</a></li><li class="chapter-item expanded affix "><li class="part-title">第一个程序 &gt; demo01_hello</li><li class="chapter-item expanded "><a href="doc/demo01_hello/1.hello.html"><strong aria-hidden="true">1.</strong> hello</a></li><li class="chapter-item expanded "><a href="doc/demo01_hello/2.editor.html"><strong aria-hidden="true">2.</strong> editor</a></li><li class="chapter-item expanded "><a href="doc/demo01_hello/3.node.html"><strong aria-hidden="true">3.</strong> node</a></li><li class="chapter-item expanded "><a href="doc/demo01_hello/4.sprite.html"><strong aria-hidden="true">4.</strong> sprite</a></li><li class="chapter-item expanded "><a href="doc/demo01_hello/5.node2d.html"><strong aria-hidden="true">5.</strong> node2d</a></li><li class="chapter-item expanded affix "><li class="part-title">基础知识 &gt; demo02_base</li><li class="chapter-item expanded "><a href="doc/demo02_base/base1.html"><strong aria-hidden="true">6.</strong> base1</a></li><li class="chapter-item expanded "><a href="doc/demo02_base/base2.html"><strong aria-hidden="true">7.</strong> base2</a></li><li class="chapter-item expanded affix "><li class="part-title">生命周期 &gt; demo03_lifecycle</li><li class="chapter-item expanded "><a href="doc/demo03_lifecycle/lifecycle.html"><strong aria-hidden="true">8.</strong> lifecycle</a></li><li class="chapter-item expanded affix "><li class="part-title">信号 &gt; demo04_signal</li><li class="chapter-item expanded "><a href="doc/demo04_signal/signal.html"><strong aria-hidden="true">9.</strong> signal</a></li><li class="chapter-item expanded affix "><li class="part-title">场景和节点 &gt; demo05_scene_node</li><li class="chapter-item expanded "><a href="doc/demo05_scene_node/scene_node.html"><strong aria-hidden="true">10.</strong> scene_node</a></li><li class="chapter-item expanded affix "><li class="part-title">移动对象 &gt; demo06_move</li><li class="chapter-item expanded "><a href="doc/demo06_move/move.html"><strong aria-hidden="true">11.</strong> move</a></li><li class="chapter-item expanded affix "><li class="part-title">碰撞 &gt; demo07_collision</li><li class="chapter-item expanded "><a href="doc/demo07_collision/collision.html"><strong aria-hidden="true">12.</strong> collision</a></li><li class="chapter-item expanded affix "><li class="part-title">组件 &gt; demo08_path</li><li class="chapter-item expanded "><a href="doc/demo08_path/path.html"><strong aria-hidden="true">13.</strong> path</a></li><li class="chapter-item expanded affix "><li class="part-title">画布屏幕 &gt; demo09_canvas</li><li class="chapter-item expanded "><a href="doc/demo09_canvas/canvas.html"><strong aria-hidden="true">14.</strong> canvas</a></li><li class="chapter-item expanded affix "><li class="part-title">动画 &gt; demo10_animation</li><li class="chapter-item expanded "><a href="doc/demo10_animation/animation.html"><strong aria-hidden="true">15.</strong> animation</a></li><li class="chapter-item expanded affix "><li class="part-title">粒子光 &gt; demo11_particle_light</li><li class="chapter-item expanded "><a href="doc/demo11_particle_light/particle.html"><strong aria-hidden="true">16.</strong> particle</a></li><li class="chapter-item expanded affix "><li class="part-title">图形用户界面 &gt; demo12_gui</li><li class="chapter-item expanded "><a href="doc/demo12_gui/gui.html"><strong aria-hidden="true">17.</strong> gui</a></li><li class="chapter-item expanded affix "><li class="part-title">摄像机视角 &gt; demo13_camera</li><li class="chapter-item expanded "><a href="doc/demo13_camera/camera.html"><strong aria-hidden="true">18.</strong> camera</a></li><li class="chapter-item expanded affix "><li class="part-title">文件操作 &gt; demo14_file</li><li class="chapter-item expanded "><a href="doc/demo14_file/file.html"><strong aria-hidden="true">19.</strong> file</a></li><li class="chapter-item expanded affix "><li class="part-title">音频 &gt; demo15_audio</li><li class="chapter-item expanded "><a href="doc/demo15_audio/audio.html"><strong aria-hidden="true">20.</strong> audio</a></li><li class="chapter-item expanded affix "><li class="part-title">http协议 demo16_http</li><li class="chapter-item expanded "><a href="doc/demo16_http/http.html"><strong aria-hidden="true">21.</strong> http</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="doc/design-pattern.html">设计模式</a></li><li class="chapter-item expanded affix "><a href="doc/editor-setup.html">编辑器使用</a></li><li class="chapter-item expanded affix "><a href="compile/godot-compile.html">其他编译器</a></li><li class="chapter-item expanded affix "><a href="doc/language-select.html">脚本语言选择</a></li><li class="chapter-item expanded affix "><a href="doc/tutorial-project.html">其他教程推荐</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GodotBook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Eninix/godot-start" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="godot-start"><a class="header" href="#godot-start">Godot Start</a></h1>
<ul>
<li>
<p>godot engine utils and sample, example, demo, tutorial, learning, course</p>
</li>
<li>
<p>目前这个项目可以在 godot 3.3，3.4，3.5中运行，不支持godot 4.x（正式版本发布才考虑支持）</p>
</li>
<li>
<p>这是一个关于godot的基本使用示例和学习教程的工程项目，<a href="https://www.bilibili.com/video/BV14Y411h7Po">B站配套视频教程</a></p>
</li>
<li>
<p><a href="https://github.com/zfoo-project/zfoo">godot服务器框架</a></p>
</li>
<li>
<p>godot start学习交流qq群，710511812</p>
</li>
</ul>
<h1 id="视频文档修正补充"><a class="header" href="#视频文档修正补充">视频文档修正补充</a></h1>
<h3 id="4安装和helloworld"><a class="header" href="#4安装和helloworld">4.安装和HelloWorld</a></h3>
<ul>
<li>建议再看看底61集的视频，黑白控制台是否隐藏，学会调整运行时候的屏幕位置，避免运行时候屏幕位置出现问题</li>
</ul>
<hr />
<p>在线书籍地址:<br />
<a href="https://eninix.github.io/godot-start/book/index.html">https://eninix.github.io/godot-start/book/index.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="godot-start项目下载"><a class="header" href="#godot-start项目下载">godot start项目下载</a></h1>
<ul>
<li>
<p>github</p>
<ul>
<li><a href="https://github.com/zfoo-project/godot-start">https://github.com/zfoo-project/godot-start</a></li>
</ul>
</li>
<li>
<p>为了防止github时不时被墙，可以把git设置一个代理，科学上网</p>
</li>
</ul>
<pre><code>git下载代码慢的解决方法|无法下载代码的解决方法
git config --global http.proxy http://127.0.0.1:10809
git config --global https.proxy https://127.0.0.1:10809
</code></pre>
<ul>
<li>godot start学习交流群，710511812</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为什么选择godot而不选择cocos-unity-ue"><a class="header" href="#为什么选择godot而不选择cocos-unity-ue">为什么选择godot，而不选择cocos, unity, ue</a></h1>
<ul>
<li>
<p>godot比cocos, unity, ue简单，更加易上手</p>
</li>
<li>
<p>godot和cocos对比</p>
<ul>
<li>godot的源代码比cocos的源代码少一倍，所以godot源代码更加的简洁，简洁的代码更容易学习底层原理</li>
<li>cocos主要都用在2D方面，2D方面godot支持的更加全面</li>
<li>GDScript比JavaScript更加简单，因为GDScript是定制过后的语言</li>
</ul>
</li>
<li>
<p>godot和unity对比</p>
<ul>
<li>unity代码不开源，但是即使开源unity的源代码体积绝对大于godot一倍以上</li>
<li>godot安装包50M，unity安装几个g</li>
<li>目前2d方面godot优于unity，3d方面unity优于godot，godot4.0有望大大缩小和unity的差距</li>
<li>GDScript学起来也比unity的C#和Lua简单</li>
</ul>
<pre><code>大部分使用unity的开发人员都在使用Lua做开发，虽然unity官方说的是用C#，但是C#不能热更新，所以实际上工作用的大部分使用的是能够热更新的Lua
比如原神就有用到Lua来去做热更新

现在需要频繁更新的功能，比如活动，在王者荣耀中这些活动大部分都是用h5页面去做了，这个只需要JavaScript就可以了，比较完美和超前的解决方案
所以unity的语言比较杂，用C#，Lua，Javascript都有可能

GDScript兼顾性能的同时，还带来比较简洁的语法，还可以热更新。
因为godot只需要用一个GDScript语言，所以远远比unity简单
</code></pre>
</li>
<li>
<p>godot和ue对比</p>
<ul>
<li>自主可控(避免被“卡脖子”)，从开源软件的角度分析，godot是游戏引擎界的Linux，ue和unity算是Windows</li>
<li>ue虽然开源源代码，但是代码量太大，历史包袱太重，不适合深入研究底层代码的人
<img src="doc/demo01_hello/image/engine-source.PNG" alt="Image text" /></li>
</ul>
</li>
<li>
<p>godot的作者尽最大努力的减少第三方库的依赖，最终使其代码非常精简，适合学习</p>
</li>
<li>
<p>源代码开源，不收费，unity和ue都是要收费的，ue超过100万美元触发5%的分成费用
<img src="doc/demo01_hello/image/apache-license.png" alt="Image text" />
<img src="doc/demo01_hello/image/gd-home.JPG" alt="Image text" /></p>
</li>
<li>
<p>使用godot你既可以用GDScript去编写代码，也可以用C++去编写代码，还可以去改底层引擎代码</p>
</li>
<li>
<p>用godot你能感觉我能把控底层，我能把控每一行代码的底层细节，这个是程序员的浪漫，godot在国外比较火是有原因的</p>
</li>
</ul>
<h1 id="为使用godot我应该选择什么语言c-or-gdscript"><a class="header" href="#为使用godot我应该选择什么语言c-or-gdscript">为使用godot我应该选择什么语言，C# or GDScript</a></h1>
<ul>
<li>GDScript快速加载无需编译，无任何等待</li>
<li>GDScript有内置的高性能类型入Vector，更加有效率</li>
<li>GDScript多线程支持更加友好，其它脚本多线程支持很差</li>
<li>GDScript直接由godot内置引擎解析</li>
<li>GDScript没有gc，没有垃圾回收器，C#带GC垃圾回收器的语言虽然也是内存安全的，但由于GC的存在，已与底层无缘</li>
<li>gds更加简单，支持的更加完整，而且是脚本可以热更新</li>
<li>C#很多库用不了，有限制，如果是为了性能可以在godot中使用C++</li>
<li>通过学习GDScript也可以学到一些编译原理的知识</li>
<li>godot不仅仅是一个游戏引擎，而且还是一个优质的学习资源</li>
<li>C#对于godot来说比较重，推荐gds</li>
</ul>
<h3 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h3>
<ul>
<li><a href="https://www.zhihu.com/question/393440831">为什么unity愿意用c#作为代码语言,而虚幻却使用c++？</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-godot的界面介绍"><a class="header" href="#1-godot的界面介绍">1. godot的界面介绍</a></h1>
<p><img src="doc/demo01_hello/image/godot-editor.PNG" alt="Image text" /></p>
<h3 id="侧面分栏dock"><a class="header" href="#侧面分栏dock">侧面分栏（Dock）</a></h3>
<ul>
<li>
<p>点击侧面分栏的右上角可以调整分栏的位置</p>
</li>
<li>
<p>左侧面分栏具体包括：</p>
<ol>
<li>文件系统（FileSystem），显示了当前项目中所有的资源文件</li>
<li>导入（Import），显示了文件系统分栏中所选资源文件的导入设置。</li>
<li>场景（Scene），按照层级结构显示当前场景中的所有节点，可以简单的理解为一个游戏里的场景/关卡</li>
</ol>
</li>
<li>
<p>右侧面分栏具体包括：</p>
<ol>
<li>属性（Inspector），显示了场景分栏中所选节点的属性。</li>
<li>节点（Node），显示了与当前场景分栏中所选节点对应的一些“信息”。</li>
</ol>
</li>
</ul>
<h3 id="中间面板"><a class="header" href="#中间面板">中间面板：</a></h3>
<ul>
<li>
<p>主工作区（Workspace）</p>
<ul>
<li>2D，当在场景分栏中所选节点为2D类型时，会自动进入此工作区。</li>
<li>3D，当在场景分栏中所选节点为3D类型时，会自动进入此工作区。</li>
<li>脚本（Script），此工作区可以对当前项目中的脚本进行编辑。</li>
<li>资源库（AssetLib），可以搜索并浏览网站上的资源</li>
</ul>
</li>
<li>
<p>底部面板（Bottom Panel）</p>
<ul>
<li>隐藏</li>
</ul>
</li>
<li>
<p>与Unity和UE4不同的是：Godot这种布局关系当前是相对固定的，即它不能随意调整任意一个面板的位置或脱离成独立的窗口。虽然这看似是一个缺点，不过从某种程度上讲也让引擎变得更简单了。</p>
</li>
<li>
<p>如果布局乱了，恢复一下就可以了，Editor | Editor Layout | Default</p>
</li>
</ul>
<h1 id="2-场景和资源"><a class="header" href="#2-场景和资源">2. 场景和资源</a></h1>
<ul>
<li>场景 Scene ，就是一个游戏里的场景 / 关卡</li>
<li>创建场景，在res面板的文件夹下右键，New Scene创建场景</li>
<li>资源 Asset，指游戏里用到的素材、脚本等数据文件</li>
</ul>
<pre><code>比如，常用的几种类型:
Texture 图片素材  ( *.jpg /  *.png)
Audio音频素材 ( *.mp3)
程序脚本GdScript ( *.gd)
</code></pre>
<ul>
<li>可以对素材执行删除 Delete 、重命名 Rename 等操作</li>
</ul>
<h1 id="3-场景视图和游戏视图"><a class="header" href="#3-场景视图和游戏视图">3. 场景视图和游戏视图</a></h1>
<ul>
<li>
<p>场景视图Scene ，即场景编辑器窗口，默认地，创建了一个场景empty</p>
</li>
<li>
<p>鼠标滚轮 ：放大/缩小视图</p>
</li>
<li>
<p>鼠标右键拖拽：平移视图</p>
</li>
<li>
<p>网格，每一个大网格包括8*8的小网格，每个小网格8个像素</p>
</li>
</ul>
<pre><code>每一个小格子为：8像素 x 8像素
每一个大格子为：64像素 x 64像素
</code></pre>
<ul>
<li>
<p>场景视图中的蓝色框区域是可见的范围，对应的就是运行游戏的时候的游戏视图</p>
</li>
<li>
<p>本教程所有的每节课都很简单，这是因为对godot的知识做了拆解，把复杂的知识拆解为一个一个简单的知识点</p>
</li>
<li>
<p>然后把每个简单的知识点单独作为一节课，所以整个课程的难度是一种渐进式的</p>
</li>
<li>
<p>复杂的东西都是由一个一个简单的知识构成的，不要觉得课程简单，如果简单的东西不熟练不练习，后面的课程很可能会跟不上</p>
</li>
</ul>
<h1 id="4-游戏对象节点"><a class="header" href="#4-游戏对象节点">4. 游戏对象（节点）</a></h1>
<ul>
<li>
<p>游戏对象 Node，就是场景中包含的内容，godot所有操作都是基于节点Node</p>
</li>
<li>
<p>演示：向Scene窗口里添加几个图片</p>
</li>
</ul>
<pre><code>1 准备图片素材
2 把图片拖到2D游戏场景中
3 在Scene窗口中，观察新加的游戏对象
</code></pre>
<ul>
<li>游戏对象的简单操作：</li>
</ul>
<pre><code>1 选中游戏对象
从左侧的层次管理器（Scene窗口）中选中游戏对象
2 移动游戏对象
选用移动工具，拖动小方块
3 修改对象名字
在Scene窗口中，可以修改名字、删除对象等操作
</code></pre>
<h1 id="5-坐标系"><a class="header" href="#5-坐标系">5. 坐标系</a></h1>
<p><img src="doc/demo01_hello/../demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB-godot-1.png" alt="Image text" /></p>
<ul>
<li>选择移动工具，移动一个对象</li>
<li>可以通过鼠标去移动游戏对象，也可以通过键盘方向键移动游戏对象，也可以手动修改position的坐标x和y去更加精确的移动对象</li>
</ul>
<pre><code>在 Inspector 属性面板：
观察对象的坐标 Position: x,  y
可以发现，对象的坐标会随之变化
</code></pre>
<ul>
<li>世界坐标系，又称为全局坐标系</li>
</ul>
<pre><code>y轴向下为正
x轴向右为正

一个像素在真实世界中，可以自行约定，比如约定1像素=1米
</code></pre>
<ul>
<li>
<p>相对坐标系，又称为局部坐标系或者本地坐标系，相对于父节点的坐标，godot的坐标都是相对坐标</p>
</li>
<li>
<p>全局坐标和局部坐标可以相互转化</p>
</li>
</ul>
<pre><code>Node2D及其子节点的位置可以使用position和gloabl_position来控制，其中，前者是该节点相对于父节点的相对位置，后者是全局位置。
简而言之，position的坐标系是以父节点的位置坐标为原点的坐标系，方向，还是水平向右为x轴正方向，竖直向下为y轴正方向。
需要注意的是，全局位置是以场景的root节点为原点的，并不是以根结点的位置作为原点的
</code></pre>
<h1 id="6-节点的基础操作"><a class="header" href="#6-节点的基础操作">6. 节点的基础操作</a></h1>
<ul>
<li>Q，选择工具，最强大的工具</li>
</ul>
<pre><code>Alt + 拖曳边框缩放点，保持选中目标中心位置不变进行缩放
Shift + 等比列缩放
Ctrl + 鼠标拖曳，以pivot为中心旋转当前对象
</code></pre>
<ul>
<li>W，移动工具，改变 Position</li>
</ul>
<pre><code>Move Mode 对象的移动：
单独改变X坐标
单独改变Y坐标
拖拽中间的方块，可以任意拖动
也可以直接在 Inspector 中输入坐标，会更精确一些
</code></pre>
<ul>
<li>R，旋转工具，改变 Rotation</li>
</ul>
<pre><code>轴心点，又称中心点，是节点的旋转中心

V，移动轴心点，Shift + V 拖拽轴心点

中心点是一个物体的中心，当我们对物体进行操作的时候，都是以中心点为中心进行对物体的操作
轴心点可以理解为把物体抽象成一个点，物体的位置就是指其轴心点的位置，就是该物体坐标系的原点
后面的课程会继续介绍轴心点

Rotate Mode 对象的旋转
沿轴心点旋转
</code></pre>
<ul>
<li>S，缩放工具，改变 Scale</li>
</ul>
<pre><code>Scale Mode 对象的缩放
沿 X 轴缩放
沿 Y 轴缩放
拖拽中间的小方块，X 和 Y 等比例缩放
</code></pre>
<ul>
<li>F，居中选取对象，非常有用的快捷键</li>
</ul>
<h1 id="7-节点操作的工具多节点选择轴心点平滑尺子"><a class="header" href="#7-节点操作的工具多节点选择轴心点平滑尺子">7. 节点操作的工具，多节点选择，轴心点，平滑，尺子</a></h1>
<ul>
<li>多节点选择工具，show a list，主要用来精确选择层叠在一起的节点</li>
<li>轴心点工具，移动轴心点，和选择工具中的快捷键V有同样的作用</li>
<li>平滑工具，固定场景</li>
<li>尺子工具，量图片或者节点的像素</li>
</ul>
<h1 id="8-智能对齐snap和锁定节点"><a class="header" href="#8-智能对齐snap和锁定节点">8. 智能对齐Snap和锁定节点</a></h1>
<ul>
<li>智能对齐，Smart Snap</li>
<li>网格对齐，Grid Snap</li>
<li>锁定节点，使其不能移动</li>
<li>子节点不可选中</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-节点的父子关系"><a class="header" href="#1-节点的父子关系">1. 节点的父子关系</a></h1>
<ul>
<li>
<p>在层级树中，对象 (节点) 呈树形显示，一个节点下面，也可以下挂子节点</p>
</li>
<li>
<p>演示：</p>
</li>
</ul>
<pre><code>1 添加两个对象
2 拖拽一个对象到另一个对象，成为子对象 (子节点)
3 移动父对象、旋转父对象，观察

可以发现，当父对象移动时，子对象随之移动
</code></pre>
<ul>
<li>理解相对坐标</li>
</ul>
<pre><code>子对象的坐标轴，是相对于父对象的
1 移动父对象时，子对象的 Position 不发生变化
2 旋转父对象时，子对象的 Rotation 不发生变化
</code></pre>
<h1 id="2-节点的显示和隐藏"><a class="header" href="#2-节点的显示和隐藏">2. 节点的显示和隐藏</a></h1>
<ul>
<li>删除游戏对象</li>
</ul>
<pre><code>右键 Delete ，或者键盘 Delete 均可
</code></pre>
<ul>
<li>恢复</li>
</ul>
<pre><code>CTRL + Z ，撤销上一步操作
</code></pre>
<ul>
<li>更改节点对象名字</li>
</ul>
<pre><code>右键 Rename，或者双击节点修改
</code></pre>
<ul>
<li>显示 / 隐藏</li>
</ul>
<pre><code>在 Inspector 里，勾选 Visible 复选框，或者在节点右侧点击Toggle Visibility
</code></pre>
<ul>
<li>设置长宽比</li>
</ul>
<pre><code>在 Project | Project Settings | Display | Window 中可以设置长宽比
</code></pre>
<h1 id="3-游戏节点的显示顺序"><a class="header" href="#3-游戏节点的显示顺序">3. 游戏节点的显示顺序</a></h1>
<ul>
<li>在2D画面中，两个对象如果重叠，谁显示在上面呢？</li>
<li>按照节点的顺序</li>
<li>在数据结构上的专业术语叫树的广度优先遍历，广度优先遍历的顺序就是最后显示的顺序</li>
</ul>
<p><img src="doc/demo01_hello/../demo05_scene_node/image/%E8%8A%82%E7%82%B9.png" alt="Image text" />
<img src="doc/demo01_hello/../demo05_scene_node/image/%E8%8A%82%E7%82%B9%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F.png" alt="Image text" /></p>
<h1 id="4-pivot轴心点"><a class="header" href="#4-pivot轴心点">4. pivot，轴心点</a></h1>
<ul>
<li>
<p>轴心点也叫中心点，中心点是一个物体的中心，当我们对物体进行操作的时候，都是以中心点为中心进行对物体的操作</p>
</li>
<li>
<p>轴心点可以理解为把物体抽象成一个点，物体的位置就是指其轴心点的位置，就是该物体坐标系的原点</p>
</li>
<li>
<p><strong>主要用于旋转和决定对象的位置</strong></p>
</li>
<li>
<p>轴心 Pivot ，指旋转轴、坐标基准点，默认在对象的几何中心</p>
</li>
<li>
<p>轴心的作用：</p>
<ul>
<li>旋转轴，当旋转对象时，是以 Pivot 为轴心来去旋转对象的</li>
<li>坐标系的原点，当移动对象时，是以 Pivot 为中心来计算位置Position的</li>
</ul>
</li>
<li>
<p>添加一个图片，设置其 Pivot 位置，多练习一下，不及小步无以至千里</p>
</li>
</ul>
<h1 id="5-anchor锚点"><a class="header" href="#5-anchor锚点">5. anchor，锚点</a></h1>
<ul>
<li>是一个点，锚点描述的是一个对象的Margin，相对于锚点的坐标</li>
<li>锚点的left，top，right，bottom是相对于父节点的值</li>
<li>主要是用于描述子节点相对于父节点的位置</li>
<li>当对一个节点的子节点进行设置锚点时，子节点的锚点范围只能够是父节点的控件区域内。</li>
<li>注意任何布局也都是相对于父窗口矩形的</li>
<li><strong>主要用于在GUI中描述子节点相对于父节点的位置</strong></li>
<li>后面的课程学到GUI中会继续介绍锚点，现在只做了解</li>
</ul>
<p><img src="doc/demo01_hello/../demo12_gui/image/gui4.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui5.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui6.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui7.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui8.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui9.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui10.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-图片素材的准备"><a class="header" href="#1-图片素材的准备">1. 图片素材的准备</a></h1>
<ul>
<li>
<p>术语：Sprite 精灵，游戏开发中指一张图片</p>
</li>
<li>
<p>来源不明的图片，切勿在商业用途使用，以免引起版权风险。做一个遵纪守法的好公民。</p>
</li>
</ul>
<pre><code>1. 在学习阶段，可以百度或者从一些资源网站获取，这种方式只能用在学习交流但是无法商用
2. 在正式工作时，公司会有专门的美术人员提供素材
3. 比较大的资源素材商店是是Unity Store
4. 独立开发者可以外包给第三方团队完成
5. 可以从一些素材网站获取正版授权的图片素材，还有一些免版权的网站一样可以获取到
6. 到一些个人外包网站如万能的淘宝或者猪八戒网，外包给大学生或其他找副业赚钱的人
</code></pre>
<ul>
<li>
<p>推荐几个国外比较好的资源网站，国内的资源网站现在还比较稀缺，需要科学上网</p>
<ul>
<li><a href="https://assetstore.unity.com/">Untiy Store</a> ，最大的游戏资源网站，可以使用里面的2D图片资源</li>
<li><a href="https://craftpix.net/">craftpix</a> ，国外的一家提供高品质的优质和免费的2D游戏资产的网站</li>
<li><a href="https://www.gamedevmarket.net/">game dev market</a> ，内容涉及2D、3D、音频和GUI素材，也可以作为一个寻找素材的补充</li>
<li><a href="https://kenney.nl/">kenney</a> ，国外一家做游戏创意原型的资源站</li>
<li><a href="https://www.fiverr.com/">Fiverr</a> ，一个综合的数字服务提供平台，可以直接在里面找到为我们工作的人，然后他们会提供一些我们定制的服务。</li>
</ul>
</li>
<li>
<p>一般人很难即精通程序也精通美术，这两种的思维方式不一样。上帝为你打开了一扇门，他同时也很可能关闭了一扇窗户</p>
</li>
<li>
<p>2D 图片的要求：</p>
</li>
</ul>
<pre><code>1 背景图片，一般为 JPG
2 人物、道具等其他图片，一般为PNG ，背景透明
</code></pre>
<ul>
<li>演示：PS处理一张图片，去掉背景，做成可用的素材</li>
</ul>
<h1 id="2-图片的切割"><a class="header" href="#2-图片的切割">2. 图片的切割</a></h1>
<ul>
<li>
<p>一个 PNG 图片中，可能包含多个素材，使用时需要切割一下</p>
<ul>
<li>第一种方式，将图片用ps之类的工具切割好以后，重新导入godot中使用</li>
<li>第二种方式，导入godot中通过Region指定使用的图片，做间接切割</li>
</ul>
</li>
<li>
<p>一个图片未经切割时，则只包含一个 Sprite素材</p>
</li>
</ul>
<h1 id="3-图片的合并"><a class="header" href="#3-图片的合并">3. 图片的合并</a></h1>
<ul>
<li>
<p>有时图片太多不好管理，想合并成一整张图片去使用</p>
<ul>
<li>第一种方式，将图片用ps之类的工具合并好以后，重新导入godot中使用</li>
<li>第二种方式，在godot中选中多张资源，然后已AtlasTexture的方式重写reimport</li>
</ul>
</li>
<li>
<p>重写reimport导入过后，也可以把之前的图片删除掉，已节省游戏的包体积和目录文件</p>
</li>
</ul>
<h1 id="4-图片与渲染器"><a class="header" href="#4-图片与渲染器">4. 图片与渲染器</a></h1>
<ul>
<li>
<p>godot是基于节点的，节点有不同的种类，不同种类的节点代表了不同的功能</p>
</li>
<li>
<p>Sprite节点继承于Node2D节点，所以包含Node2D节点的所有属性</p>
</li>
<li>
<p>Sprite节点，用于显示一个Sprite，把一张图片渲染出来</p>
</li>
<li>
<p>节点的种类表示一种功能，而 Sprite 的功能就是显示图片，后面还会说</p>
</li>
<li>
<p>演示和练习：</p>
</li>
</ul>
<pre><code>1 添加一个对象，显示图片1
2 观察 Sprite 的属性值
3 让 Sprite Renderer 更换显示另一张图片，通过拖拽方式或者通过选择文件的方式
4 通过创建一个节点的方式创建Sprite节点
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-节点和功能的关系"><a class="header" href="#1-节点和功能的关系">1. 节点和功能的关系</a></h1>
<ul>
<li>
<p>节点 Node ，用于实现一种功能，例如，Sprite 节点，用于图片的显示</p>
</li>
<li>
<p>一个节点的功能取决于它挂载了哪些子节点，它包含了哪些功能的子节点，就包含了对应子节点表示的功能</p>
</li>
<li>
<p>节点是可选的，可以添加、可以删除</p>
</li>
<li>
<p>先创建一个空的节点，再选择需要的节点</p>
</li>
</ul>
<p><img src="doc/demo01_hello/image/node2d-00.JPG" alt="Image text" /></p>
<pre><code>Sprite用来显示一张图片，再给Sprite增加一个刚体

演示：
1 添加一个空的节点Node
2 挂载 Sprite 节点，然后再挂载RigidBody2D刚体节点
3 移除RigidBody2D刚体节点
</code></pre>
<h1 id="2-node节点"><a class="header" href="#2-node节点">2. Node节点</a></h1>
<ul>
<li>Node节点，是基类节点，所有节点都会继承Node节点，所以其它类型都包含Node节点的功能</li>
<li>Node节点是最核心的节点，所有其他类型节点都是由Node节点派生出来的</li>
</ul>
<p><img src="doc/demo01_hello/image/node2d-01.JPG" alt="Image text" /></p>
<pre><code>1. Pause Mode节点的暂停
get_tree().paused = true
节点的三种可能状态有:

Inherit（继承） ：处理与否取决于父、祖父等等节点中第一个非 Inherit 状态的节点。
Stop（停止） ：无条件停止节点（以及 Inherit 模式的子节点）。暂停时该节点不会进行处理。
Process（处理） ：无条件处理节点（以及 Inherit 模式的子节点）。无论暂停与否，该节点都会进行处理。

process方法执行的优先级，对于子节点依然有效

挂载外部的脚本

</code></pre>
<pre><code># 脚本初始化会首先调用这个方法，会在_process()方法之前调用
func _ready():
	# get_tree().paused = true
	pass

var count = 0
# 每一帧都会调用这个方法
func _process(delta):
	count = count + 1
	
	if (count % 60 == 0):
		print(&quot;parent node&quot;)
	pass
</code></pre>
<h1 id="3-canvasitem节点"><a class="header" href="#3-canvasitem节点">3. CanvasItem节点</a></h1>
<ul>
<li>
<p>CanvasItem节点，CanvasItem -&gt; Node</p>
</li>
<li>
<p>Canvas是画布的意思，所以CanvasItem代表了就是可以被绘制节点，可以设置可视化界面和材质的颜色</p>
</li>
<li>
<p>所有的2D节点和GUI节点都继承于CanvasItem节点</p>
</li>
<li>
<p>CanvasItem是按树的树的广度优先遍历顺序绘制的</p>
</li>
<li>
<p>可以通过设置CanvasItem的Show Behind Parent来改变最终渲染到屏幕上的画面顺序</p>
</li>
</ul>
<pre><code>Texture 贴图，附加到物体表面的贴图
Material 材质，物体的质地，指色彩，纹理，光滑度，透明度，反射率，折射率，发光度。实际就是Shader
Shader 着色器，使用代码来渲染图形的技术，可以控制GPU运算图像效果的一段代码
</code></pre>
<h1 id="4-node2d节点"><a class="header" href="#4-node2d节点">4. Node2D节点</a></h1>
<ul>
<li>Node2D节点，Node2d -&gt; CanvasItem -&gt; Node</li>
</ul>
<pre><code>Node2D节点继承于CanvasItem节点，CanvasItem节点继承于Node节点，所以Node2D节点包括了CanvasItem节点和Node节点的所有功能

Transform ，Node2d节点的基本属性，在后面的脚本编程中，Transform属性是最常用的
表示：
 - Position 位置
 - Rotation 旋转
 - Scale 缩放
</code></pre>
<h1 id="5-自定义节点"><a class="header" href="#5-自定义节点">5. 自定义节点</a></h1>
<ul>
<li>
<p>当发现现有的节点无法支持新的需求的时候，有两种方法去解决，自定义节点或者自定义脚本，核心都是脚本</p>
</li>
<li>
<p>创建GdScrip脚本，叫MyNode，继承Node2D节点，并自定义节点的icon</p>
</li>
</ul>
<pre><code>extends Node2D

class_name MyNode, &quot;res://icon.png&quot;
</code></pre>
<ul>
<li>编写脚本，定义变量，编写代码</li>
</ul>
<pre><code>export var a = 1
export var b:String
</code></pre>
<ul>
<li>
<p>保存，如果不保存无法看到我们创建到的节点，这一点需要特别注意</p>
</li>
<li>
<p>添加刚刚创建的自定义节点</p>
</li>
</ul>
<h1 id="6-节点继承"><a class="header" href="#6-节点继承">6. 节点继承</a></h1>
<ul>
<li>通过继承现有节点，来改变已有节点的功能</li>
<li>无论是自定义节点还是节点继承，核心都通过脚本控制达到自己想要的效果</li>
<li>从下节课开始说GdScript脚本</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-脚本的定义"><a class="header" href="#1-脚本的定义">1. 脚本的定义</a></h1>
<ul>
<li>游戏脚本 Script ，用代码来控制游戏对象</li>
<li>godot使用 GdScript 作为脚本语言</li>
<li>注意：自本章开始，每节课的项目源码都放在了github项目godot-start，可以直接对照示例项目</li>
<li>游戏开发，也是一种程序设计，如果是0基础的同学，建议先学习一个强类型语言比如Java，C#，C++，再来学习GdScript就一通百通了</li>
</ul>
<h1 id="2-脚本的使用"><a class="header" href="#2-脚本的使用">2. 脚本的使用</a></h1>
<ul>
<li>如何使用一个脚本？</li>
</ul>
<pre><code>新建脚本 hello.gd ，编辑代码 ，保存一下
把脚本挂载到游戏节点上
运行游戏，点 Play Scene 运行当前游戏场景，在 Output 窗口里观察打印输出
</code></pre>
<h1 id="3-认识脚本"><a class="header" href="#3-认识脚本">3. 认识脚本</a></h1>
<ul>
<li>因为是GdScript是弱类型语言，所以比较自由，但是我们可以约定一些原则让代码更加的规范：</li>
</ul>
<pre><code>类名必须与文件名相同，且为小写
尽量继承于 Node2D 节点，Node2D 节点中的Transform是我们用的最多的节点
</code></pre>
<ul>
<li>常用函数内部执行顺序，_init  _ready  _process</li>
</ul>
<pre><code>默认定义了一些事件函数，例如，
  _init()  脚本初始化的时候调用，对象的构造器，类似于Java的构造函数construct
  _ready()  开始调用一次，可用于初始化脚本
  _process(delta) 每帧调用，帧间隔不等，可用于更新游戏
</code></pre>
<h1 id="4变量和数据类型"><a class="header" href="#4变量和数据类型">4.变量和数据类型</a></h1>
<ul>
<li>变量是用于存储信息的&quot;容器&quot;。</li>
</ul>
<pre><code>var x=5;
var y=6;
var z=x+y;

就像代数那样
x=5
y=6
z=x+y

在代数中，我们使用字母（比如 x）来保存值（比如 5）。
通过上面的表达式 z=x+y，我们能够计算出 z 的值为 11。
在 godot 中，这些字母被称为变量。
</code></pre>
<ul>
<li>gds数据类型分类
<ul>
<li>bool，一个字节，默认为false</li>
<li>int(同C++和Java long)，8个字节，默认为0</li>
<li>float(同C++和Java double)，8个字节，默认为0</li>
<li>String，默认为null，字符串可以存储一系列字符，如 &quot;John Doe&quot;。</li>
<li>数组</li>
<li>对象</li>
<li>null，变量没有被赋值，则默认为null</li>
</ul>
</li>
</ul>
<p><img src="doc/demo02_base/image/integer.JPG" alt="Image text" />
<img src="doc/demo02_base/image/integer_overflow.JPG" alt="Image text" />
<img src="doc/demo02_base/image/step.JPG" alt="Image text" /></p>
<h1 id="5导出变量"><a class="header" href="#5导出变量">5.导出变量</a></h1>
<ul>
<li>export关键字可以让变量在编辑器中编辑</li>
</ul>
<pre><code># 导出一个数字
export var a = 1
# 导出一个节点路径
export var b:NodePath
# 导出一个节点路径，不同的写法
export(NodePath) var c
# 导出一个文件路径
export(String, FILE) var e 
# 导出一个文件路径，以txt结尾
export(String, FILE, &quot;*.txt&quot;) var d
# 导出一个资源文件路径
export(Resource) var f
# 导出一个颜色
export(Color, RGB) var g
</code></pre>
<h1 id="6函数"><a class="header" href="#6函数">6.函数</a></h1>
<ul>
<li>函数是可以简单的理解为当它被调用时执行的可重复使用的代码块。</li>
<li>函数就是包裹在花括号中的代码块，前面使用了关键词 func，当调用该函数时，会执行函数内的代码。</li>
<li>空函数需要使用pass关键字</li>
</ul>
<pre><code>func sayHello():
    # 执行代码
</code></pre>
<ul>
<li>调用带参数的函数，在调用函数时，您可以向其传递值，这些值被称为参数。</li>
</ul>
<pre><code>func sayHello(param1， param2):
    # 执行代码
</code></pre>
<ul>
<li>带有返回值的函数，有时，我们会希望函数将值返回调用它的地方，通过使用 return 语句就可以实现。</li>
<li>return方法可以指定返回的类型</li>
</ul>
<pre><code>func sayHello(param1， param2):
    # 执行代码
    return x
</code></pre>
<h1 id="7变量的作用域"><a class="header" href="#7变量的作用域">7.变量的作用域</a></h1>
<ul>
<li>局部作用域，变量在函数内声明，变量为局部作用域，只能在函数内部访问</li>
</ul>
<pre><code># 此处不能调用 carName 变量
func myFunction():
    var carName = &quot;Volvo&quot;;
    # 函数内可调用 carName 变量
</code></pre>
<ul>
<li>全局变量，变量在函数外定义，即为全局变量，整个脚本文件中都可以使用</li>
</ul>
<pre><code>var carName = &quot; Volvo&quot;;
 
# 此处可调用 carName 变量
func myFunction():
    # 函数内可调用 carName 变量
</code></pre>
<h1 id="8-运算符"><a class="header" href="#8-运算符">8. 运算符</a></h1>
<ul>
<li>算术运算符</li>
</ul>
<pre><code>+	加法	        x=y+2	7	5
-	减法	        x=y-2	3	5
*	乘法	        x=y*2	10	5
/	除法	        x=y/2	2.5	5
%	取模（余数）	x=y%2	1	5
</code></pre>
<ul>
<li>赋值运算符，赋值运算符用于给 GdScript 变量赋值</li>
</ul>
<pre><code>=	x=y	 	x=5
+=	x+=y	x=x+y	x=15
-=	x-=y	x=x-y	x=5
*=	x*=y	x=x*y	x=50
/=	x/=y	x=x/y	x=2
%=	x%=y	x=x%y	x=0
</code></pre>
<ul>
<li>比较运算符，比较运算符在逻辑语句中使用，以测定变量或值是否相等</li>
</ul>
<pre><code>==	等于	x==8	false
!=	 不等于	x!=8	true
&gt;	 大于	x&gt;8	false
&lt;	 小于	x&lt;8	true
&gt;=	 大于或等于	x&gt;=8	false
&lt;=	 小于或等于	x&lt;=8	true
</code></pre>
<ul>
<li>逻辑运算符，逻辑运算符用于测定变量或值之间的逻辑。</li>
</ul>
<pre><code>&amp;&amp;	and	(x &lt; 10 &amp;&amp; y &gt; 1) 为 true
||	or	(x==5 || y==5) 为 false
!	not	!(x==y) 为 true
</code></pre>
<h1 id="9-条件语句"><a class="header" href="#9-条件语句">9. 条件语句</a></h1>
<ul>
<li>
<p>通常在写代码时，您总是需要为不同的决定来执行不同的动作。您可以在代码中使用条件语句来完成该任务。</p>
</li>
<li>
<p>if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码</p>
</li>
</ul>
<pre><code>if (condition):
    当条件为 true 时执行的代码
</code></pre>
<ul>
<li>if...else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li>
</ul>
<pre><code>if (condition):
    当条件为 true 时执行的代码
else:
    当条件不为 true 时执行的代码
</code></pre>
<ul>
<li>if...else if....else 语句- 使用该语句来选择多个代码块之一来执行</li>
</ul>
<pre><code>if (condition1):
    当条件 1 为 true 时执行的代码
elif (condition2):
    当条件 2 为 true 时执行的代码
else:
  当条件 1 和 条件 2 都不为 true 时执行的代码
</code></pre>
<ul>
<li>match(switch) 语句 - 使用该语句来选择多个代码块之一来执行</li>
</ul>
<h1 id="10-循环语句"><a class="header" href="#10-循环语句">10. 循环语句</a></h1>
<ul>
<li>循环可以将代码块执行指定的次数，如果您希望一遍又一遍地运行相同的代码，并且每次的值都不同，那么使用循环是很方便的</li>
<li>for</li>
<li>while</li>
<li>break 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）</li>
<li>continue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代</li>
</ul>
<h1 id="11-数组和字典的遍历"><a class="header" href="#11-数组和字典的遍历">11. 数组和字典的遍历</a></h1>
<ul>
<li>数组遍历</li>
</ul>
<pre><code>func arrayIterator():
	# range等价于for(int i = 0; i &lt; 20; i++)
	print(&quot;数组遍历方法1：&quot;)
	for i in range(3):
		print(i)
	print(&quot;数组遍历方法2：&quot;)
	for ele in arr:
		print(ele)
	print(&quot;数组遍历方法3：&quot;)
	for index in range(arr.size()):
		print(arr[index])
</code></pre>
<ul>
<li>字典遍历</li>
</ul>
<pre><code>func dictionaryIterator():
	print(&quot;字典遍历方法1：&quot;)
	for key in dict:
		print(&quot;key:&quot; + key as String)
		print(&quot;value:&quot; + dict[key] as String)
		
	print(&quot;字典遍历方法2：&quot;)
	for key in dict.keys():
		print(&quot;key:&quot; + key as String)
		print(&quot;value:&quot; + dict[key] as String)
		
	print(&quot;字典遍历方法3：&quot;)
	for value in dict.values():
		print(&quot;value:&quot; + value as String)	
</code></pre>
<h1 id="12-静态变量和静态方法"><a class="header" href="#12-静态变量和静态方法">12. 静态变量和静态方法</a></h1>
<ul>
<li>const变量（静态变量）</li>
</ul>
<pre><code>const ANSWER = 42
</code></pre>
<ul>
<li>静态方法</li>
</ul>
<pre><code>static func getAnswer():
	return ANSWER
</code></pre>
<h1 id="13-对象"><a class="header" href="#13-对象">13. 对象</a></h1>
<ul>
<li>真实生活中的对象，属性和方法</li>
<li>真实生活中，一辆汽车是一个对象。对象有它的属性，如重量和颜色等，方法有启动停止等</li>
</ul>
<pre><code># Inner class，默认继承Object
class Animal:
	extends Object  # 如果不指定继承的类，默认基础Object
	const STATIC_FIELD = &quot;静态变量&quot;
	# 属性
	var height: int
	
	func _init():
		print(&quot;Animal 构造方法&quot;)
		
	func move():
		print(&quot;animal，移动&quot;)
	
	static func staticFuction():
		pass
</code></pre>
<h1 id="14-调试"><a class="header" href="#14-调试">14. 调试</a></h1>
<ul>
<li>在编写 GdScript 时，如果没有调试工具将是一件很痛苦的事情。</li>
<li>你的代码可能包含语法错误，逻辑错误，有了调试工具，这些错误比较容易发现。</li>
</ul>
<h1 id="15-参考资料"><a class="header" href="#15-参考资料">15. 参考资料</a></h1>
<ul>
<li><a href="https://docs.godotengine.org/en/stable/getting_started/scripting/gdscript/gdscript_basics.html">godot官方文档</a></li>
<li><a href="https://www.youtube.com/watch?v=JJQa3xrRNM0&amp;list=PLJ690cxlZTgL4i3sjTPRQTyrJ5TTkYJ2_">Godot Tutorials的GDScript Fundamentals Tutorial Series，youtube播放量最高的godot教程视频</a></li>
<li><a href="https://www.youtube.com/watch?v=sChM51ibm5k&amp;list=PLJ690cxlZTgIsmdEhFufnB7O6KWoMS8M6">Godot Tutorials的Godot Basics Tutorial Series，youtube播放量最高的godot教程视频</a></li>
<li><a href="https://www.bilibili.com/video/BV17g4y1z7uS">B站视频</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-内存管理free"><a class="header" href="#1-内存管理free">1. 内存管理free</a></h1>
<ul>
<li>
<p>godot中的对象分为两种</p>
<ul>
<li>引用计数对象，继承于Reference，当没有引用时会被自动回收</li>
<li>非引用计数对象，没有继承于Reference，自能自己手动回收,free或queue_free</li>
</ul>
</li>
<li>
<p>在godot中，移除一个节点并不会从节点中删除，必须手动调用free或queue_free</p>
</li>
</ul>
<p><img src="doc/demo02_base/image/gc.JPG" alt="Image text" /></p>
<h1 id="2-垃圾回收的缺点"><a class="header" href="#2-垃圾回收的缺点">2. 垃圾回收的缺点</a></h1>
<p><img src="doc/demo02_base/image/gc1.png" alt="Image text" />
<img src="doc/demo02_base/image/gc2.png" alt="Image text" />
<img src="doc/demo02_base/image/gc3.png" alt="Image text" /></p>
<ul>
<li>GdScript没有垃圾回收，虽然有着内存泄露的风险，但是也保证了性能</li>
</ul>
<h1 id="3-引用计数算法"><a class="header" href="#3-引用计数算法">3. 引用计数算法</a></h1>
<ul>
<li>
<p>对于创建的每一个对象都有一个与之关联的计数器，这个计数器记录着该对象被使用的次数</p>
</li>
<li>
<p>可以立即回收垃圾。因为每个对象在被引用次数为0的时候，是立即就可以知道的。</p>
</li>
<li>
<p>没有暂停时间。这个很容易理解，对象的回收根本不需要另外的GC线程专门去做，业务线程自己就搞定了。</p>
</li>
<li>
<p>不需要stop the world，当然，在多线程的情况下，必要的同步和互斥操作还是需要的。</p>
</li>
<li>
<p>一个致命缺陷是循环引用，就是， objA引用了objB，objB也引用了objA。这种情况下，这两个对象是不能被回收的。
<img src="doc/demo02_base/image/cycle.JPG" alt="Image text" /></p>
</li>
<li>
<p>可以使用unreference去释放引用计数的对象</p>
</li>
<li>
<p>引用计数既保留了性能，也保证了更加高效的性能
<img src="doc/demo02_base/image/%E5%A4%AA%E6%9E%81.png" alt="Image text" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-场景树"><a class="header" href="#1-场景树">1. 场景树</a></h1>
<ul>
<li>Nodes（节点）是在Godot中创建游戏的基本构建块。当一组节点被添加到树中时，它被称为sence（场景），树被称为sence tree（场景树）</li>
</ul>
<pre><code>节点是可以表示各种专用游戏功能的对象。给定类型的节点可以显示图形，播放动画或表示对象的3D模型。
该节点还包含一组属性，允许你自定义其行为。
你添加到项目中的节点取决于你需要的功能。
它是一个模块化系统，旨在为你提供构建游戏对象的灵活性。

在项目中，你添加的节点将组织为树结构。在树中，节点被添加为其他节点的子节点。
特定节点可以具有任意数量的子节点，但只能有一个父节点。
</code></pre>
<p><img src="doc/demo03_lifecycle/image/scene-tree.png" alt="Image text" /></p>
<h1 id="2-帧率"><a class="header" href="#2-帧率">2. 帧率</a></h1>
<ul>
<li>帧率 Framerate ，指画面每秒更新多少次 (FPS, Frames Per Second)</li>
</ul>
<pre><code>比如，
  FPS = 50 , 即每 20ms 秒更新一次
  FPS = 60,  约 16.7ms 秒更新一次

通过代码可以设置，要求 godot 引擎尽量以此帧率运行 ，但实际帧率还是会有偏差
Engine.target_fps = 120
</code></pre>
<p><img src="doc/demo03_lifecycle/image/%E5%9C%BA%E6%99%AF%E5%BE%AA%E7%8E%AF.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/%E5%9C%BA%E6%99%AF%E5%B8%A7.png" alt="Image text" /></p>
<ul>
<li>delta time上一帧的间隔</li>
</ul>
<pre><code>匀速移动的优化：
 var step = 0.8f * deltaTime;
其中，
   0.8f  表示每秒位移 0.8 单位
</code></pre>
<p><img src="doc/demo03_lifecycle/image/delta.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/delta-1.png" alt="Image text" /></p>
<h1 id="3-节点的生命周期"><a class="header" href="#3-节点的生命周期">3. 节点的生命周期</a></h1>
<ul>
<li>在Godot中，一个游戏的启动大致流程如下：</li>
</ul>
<pre><code>Godot的main启动一个进程，加载所需的驱动设备（如渲染设备：GL/GLES/Vulkan等）、音频设备，输入控制器设备等等；

然后进入主循环，加载一个自动创建的对象——SceneTree（场景管理系统对象，它用户管理场景图），
这个对象包含一个RootViewPort节点（它是一个Node），该节点包含一个默认的ViewPort（以便提供默认渲染的输出视口）。

当用户用Godot编辑器创建一个关卡（或场景文件），并设置默认的启动的场景文件，Godot将该场景文件的根节点附加到RootViewPort节点上，
当节点进入场景树（SceneTree），变为活动状态。
按场景树顺序依次回调各个子节点的_init()，_ready()等声明函数。
</code></pre>
<p><img src="doc/demo03_lifecycle/image/godot_process.jpg" alt="Image text" />
<img src="doc/demo03_lifecycle/image/godot_node.jpg" alt="Image text" />
<img src="doc/demo03_lifecycle/image/godot_lifecycle.jpg" alt="Image text" /></p>
<h1 id="4-节点的获取方式"><a class="header" href="#4-节点的获取方式">4. 节点的获取方式</a></h1>
<pre><code># 获取当前节点
var currentNode1 = $&quot;.&quot;
var currentNode2 = self

# 获取父节点
var parentNode1 = get_parent()
var parentNode2 = $&quot;../&quot;

# 获取子节点
var subNode1 = $SubNode2
var subNode2 = $&quot;SubNode2&quot;
var subNode3 = get_node(&quot;SubNode2&quot;)

# 根节点查找法，会返回节点树从上到下找到的第一个节点
var subNode4 = get_tree().root.find_node(&quot;SubNode2&quot;, true, false)
</code></pre>
<h1 id="5-process和physics_process"><a class="header" href="#5-process和physics_process">5. process和physics_process</a></h1>
<ul>
<li>平时我们看到的动画，实际上是由很多静止的画面连续切换组成的</li>
<li>其中每个静止的画面，我们都称为一帧，比如60帧的动画，就是一秒播放60个静止的画面，组成的动画</li>
<li>godot 的 _process 相当于 unity 的 Update</li>
</ul>
<pre><code>内部对代码就会在每一帧之前被执行，也就是引擎每渲染一幅的画面之前，都会执行它里面的代码
</code></pre>
<ul>
<li>godot 的 _physics_process 相当于 unity 的 FixedUpdate</li>
</ul>
<pre><code>内部的代码会在每个物理帧之前被执行，
因为godot的物理模拟是单独进行的，每次进行物理模拟的时候，如计算一个刚体小球的运动轨迹，每进行一次计算，我们就称为是一进行了一个物理帧，
而每次进行物理模拟之前，都会执行_physics_process中的代码
</code></pre>
<p><img src="doc/demo03_lifecycle/image/process.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/process-1.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/physics.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/physics-1.png" alt="Image text" /></p>
<h1 id="6-parent和owner"><a class="header" href="#6-parent和owner">6. Parent和Owner</a></h1>
<ul>
<li>
<p>Parent</p>
<ul>
<li>一个节点的Parent就是场景树上它的父级</li>
</ul>
</li>
<li>
<p>Owner</p>
<ul>
<li>如果不修改默认Owner的话，可以把它视为节点所在场景的顶部节点，如果该节点本身就是顶部节点那么它的Owner为null</li>
</ul>
</li>
<li>
<p>静态场景结构中默认的Owner</p>
</li>
</ul>
<p><img src="doc/demo03_lifecycle/image/owner01.png" alt="Image text" /></p>
<pre><code>extends Node

class_name TestNode

func _ready():
	var parent_name = &quot;NULL&quot;
	var owner_name = &quot;NULL&quot;
	if get_parent() != null:
		parent_name = get_parent().name
	if owner != null:
		owner_name = owner.name
	print(name + &quot;'s parent is &lt;&quot; + parent_name + &quot;&gt; and it's owner is &lt;&quot; + owner_name + &quot;&gt;&quot; )
	
</code></pre>
<pre><code>node_3's parent is &lt;node_2&gt; and it's owner is &lt;node_0&gt;
node_2's parent is &lt;node_1&gt; and it's owner is &lt;node_0&gt;
node_1's parent is &lt;node_0&gt; and it's owner is &lt;node_0&gt;
node_0's parent is &lt;root&gt; and it's owner is &lt;NULL&gt;
</code></pre>
<ul>
<li>动态创建的节点的Owner是null</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-信号signal"><a class="header" href="#1-信号signal">1. 信号signal</a></h1>
<ul>
<li>
<p>信号是用来完成模块或功能之间通信的媒介，其实就是约定了一些方法的回调形式</p>
</li>
<li>
<p>设计模式上叫做观察者设计模式</p>
</li>
</ul>
<pre><code>1. 观察者和被观察者是抽象耦合的，解耦模块 
2. 建立一套统一的触发机制
</code></pre>
<ul>
<li>
<p>Godot引擎官方建议在你的游戏开发中更多的使用信号来完成模块或功能间的通信</p>
</li>
<li>
<p>第一种使用方法</p>
</li>
</ul>
<pre><code># 第一种信号接受方法，通过在场景中配置信号的接收方法
func _on_Button1_pressed():
	print(&quot;hello button1&quot;)
</code></pre>
<ul>
<li>第二种使用方法</li>
</ul>
<pre><code># 第二种信号接受方法，通过代码控制信号的接收，更加的灵活，比较推荐方式
func _ready():
	$Button2.connect(&quot;pressed&quot;, self, &quot;onButton2&quot;)
	
func onButton2():
	print(&quot;button2 pressed&quot;)
</code></pre>
<h1 id="2-自定义信号"><a class="header" href="#2-自定义信号">2. 自定义信号</a></h1>
<ul>
<li>自定义信号</li>
</ul>
<pre><code>signal mySignal(a, b)
</code></pre>
<ul>
<li>发送信号</li>
</ul>
<pre><code>emit_signal(&quot;mySignal&quot;, 1, 2)
</code></pre>
<ul>
<li>解除绑定信号</li>
</ul>
<pre><code>disconnect(&quot;mySignal&quot;, 1, 2)
</code></pre>
<h1 id="3-异步回调yield"><a class="header" href="#3-异步回调yield">3. 异步回调yield</a></h1>
<ul>
<li>yield, to produce a result, answer, or piece of information，立即结束当前函数调用，无需等待</li>
</ul>
<pre><code>其本质，就是能让一个函数在执行过程中暂停（挂起），然后在接收到恢复指令以后继续执行的机制。
</code></pre>
<ul>
<li>yield(obj, signal)，函数立即返回，并且保存当前执行的位置和状态</li>
</ul>
<pre><code>GDScriptFunctionState yield( Object object=null, String signal=&quot;&quot; )
</code></pre>
<ul>
<li>yield返回GDScriptFunctionState类型对象，类似于Java的CompleteFuture</li>
</ul>
<pre><code>GDScriptFunctionState 是记录一个协程状态的对象，实际上它就代表(引用)着该协程。
</code></pre>
<ul>
<li>resume恢复GDScriptFunctionState保存的调用函数状态</li>
</ul>
<p><img src="doc/demo04_signal/image/yield.JPG" alt="Image text" /></p>
<ul>
<li>yield的三种用法</li>
</ul>
<ol>
<li>yield()和resmue()组合，yield()来挂起，用resmue()来恢复</li>
<li>yield(对象,信号S)的形式，把这个协程（即 GDScriptFunctionState）注册为 节点N上信号S的接收者，当 节点N发出信号S以后，函数会恢复执行。</li>
<li>yield(协程对象C,&quot;completed&quot;)的形式，协程失效（即GDScriptFunctionState的is_valid为false）以后，它会释放一个&quot;completed&quot;信号，用这个信号恢复上一层协程。</li>
</ol>
<h1 id="4-多线程"><a class="header" href="#4-多线程">4. 多线程</a></h1>
<ul>
<li>什么是进程？</li>
</ul>
<pre><code>电脑中有时会有很多单独运行的程序，每个程序有一个独立的进程，而进程之间是相互独立存在的。比如QQ、浏览器
</code></pre>
<ul>
<li>什么是线程？</li>
</ul>
<pre><code>进程想要执行任务就需要依赖线程。换句话说，就是进程中的最小执行单位就是线程，并且一个进程中至少有一个线程。
</code></pre>
<ul>
<li>那什么是多线程？提到多线程这里要说两个概念，就是串行和并行，搞清楚这个，我们才能更好地理解多线程。</li>
<li>串行，其实是相对于单条线程来执行多个任务来说的，比如下载一个文件要等到上一个文件下载完</li>
<li>并行，下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的，在同一时刻发生的，并行在时间上是重叠的</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-屏幕窗口设置"><a class="header" href="#1-屏幕窗口设置">1. 屏幕窗口设置</a></h1>
<ul>
<li>
<p>Editor | Editor Settings | Editor，设置控制台是否隐藏
<img src="doc/demo05_scene_node/image/console.JPG" alt="Image text" /></p>
</li>
<li>
<p>Editor | Editor Settings | Window Placement，设置编辑器运行游戏窗口的位置
<img src="doc/demo05_scene_node/image/window01.jpg" alt="Image text" /></p>
</li>
<li>
<p>Project | Project Settings | Display，设置游戏窗口的大小等相关参数
<img src="doc/demo05_scene_node/image/window02.jpg" alt="Image text" /></p>
</li>
<li>
<p>Project | Project Settings | Display | Hide Home Indicator，ios的 Home 键指示隐藏
<img src="doc/demo05_scene_node/image/ios.JPG" alt="Image text" /></p>
</li>
</ul>
<h1 id="2-单位和像素"><a class="header" href="#2-单位和像素">2. 单位和像素</a></h1>
<ul>
<li>
<p>屏幕分辨率（屏幕像素），屏幕分辨率上的像素点数，单位是px，4:3 是最常见屏幕比例，显示设置可以看到</p>
</li>
<li>
<p>图片像素</p>
<p><img src="doc/demo05_scene_node/image/pixel.jpg" alt="Image text" /></p>
</li>
<li>
<p>屏幕像素和图片像素有什么关系</p>
</li>
</ul>
<pre><code>在屏幕显示图片时，如果屏幕的长宽比或者像素数和图片一致，只需要每个屏幕像素的像素点表示出图片上的像素就可以了，1:1对应显示出来。
那如果图片像素数和屏幕像素数不一样呢？

当图片像素大于屏幕像素时，屏幕也是进行合并显示的。
比如一张1200W像素的图片，要在300W像素的显示器（长宽比一致）上显示，那么系统就需要将图片像素进行四合一计算然后再显示。
当图片像素数大于屏幕像素数时，高像素图片和低像素图片的显示精细度是一样的！
</code></pre>
<ul>
<li>DPI（dots per inch），DPI在高分辨率显示器和手机普及之后，调了之后，画面上的字体等会变大变小。</li>
</ul>
<pre><code>比如我使用一个27寸的4k显示器，如果DPI 100%的话，那么字体就是27英寸的1080p显示器的1/4大小，完全没法看了。
这个时候，使用DPI 200%，字就又大又清楚了。

这个过程在windows上面就是DWM（desktop windows manager）做了scaling。
</code></pre>
<ul>
<li>在godot中，一般position的1个单位长度等于1个图片像素</li>
</ul>
<h1 id="3-垂直同步"><a class="header" href="#3-垂直同步">3. 垂直同步</a></h1>
<ul>
<li>Vsync，垂直同步又称场同步（Vertical Hold）</li>
</ul>
<pre><code>我们平时所说的打开垂直同步指的是将该信号送入显卡3D图形处理部分，从而让显卡在生成3D图形时受垂直同步信号的制约。

当我们选择&quot;等待垂直同步信号&quot;（即打开垂直同步）时，显卡绘制3D图形前会等待垂直同步信号，
当该信号到达时，显卡开始绘制3D图形，如果显卡性能较为强劲，在下个垂直同步信号到来之前已经完成了对该帧的渲染，
显卡就会暂停处理，等下个垂直同步信号到来后才开始渲染下一帧。
由此可见，当打开垂直同步时，游戏的FPS要受刷新率的制约，对于高端显卡而言，限制了其性能的发挥。

假设我们选择不等待垂直同步信号（也就是我们平时所说的关闭垂直同步），
那么游戏中屏幕渲染完整个屏幕的画面后，显卡和显示器无需等待垂直同步信号就能够开始下一屏图像的绘制，自然能够全然发挥显卡的实力。
可是不要忘记，正是由于垂直同步的存在，才使得游戏进程和显示器刷新率同步，使得画面更加平滑和稳定。
取消了垂直同步信号，固然能够换来更快的速度，可是在图像的连续性上势必打折扣。
这也正是非常多朋友抱怨关闭垂直后发现画面不连续的理论原因。
</code></pre>
<p><img src="doc/demo05_scene_node/image/window03.jpg" alt="Image text" /></p>
<ul>
<li>CRT显示器学名为“阴极射线显像管”，是一种使用阴极射线管（Cathode Ray Tube）的显示器。</li>
</ul>
<pre><code>屏幕上的图形图像是由一个个电子束击打屏幕而发光的荧光点组成

电子枪从屏幕的左上角的第一行(行的多少根据显示器当时的分辨率所决定，比如800X600分辨率下，电子枪就要扫描600行)开始，从左至右逐行扫描，
第一行扫描完后再从第二行的最左端开始至第二行的最右端，一直到扫描完整个屏幕后再从屏幕的左上角开始，这时就完成了一次对屏幕的刷新，周而复始。

从CRT显示器的显示原理来看，单个像素组成了水平扫描线，水平扫描线在垂直方向的堆积形成了完整的画面。
显示器的刷新率受显卡DAC控制，显卡DAC完成一帧的扫描后就会产生一个垂直同步信号。
</code></pre>
<ul>
<li>液晶显示器借助于薄膜晶体管驱动的有源矩阵液晶显示器，它主要是以电流刺激液晶分子产生点、线、面配合背部灯管构成画面。</li>
</ul>
<pre><code>
在电场的作用下，利用液晶分子的排列方向发生变化，使外光源透光率改变（调制），完成电一光变换，
再利用R、G、B三基色信号的不同激励，通过红、绿、蓝三基色滤光膜，完成时域和空间域的彩色重显。

LCD的刷新率与CRT不同，因为LCD和CRT的显像方式不同，CRT是靠不断刷新画面来使显示器显示图像的，而LCD只要改变发光颗粒就能使显示器中的画面动起来
正是由于LCD与CRT显像方式不同，LCD显示器本身不会出现屏幕闪烁的现象

打开垂直同步可以使得画面平滑、稳定。
关闭垂直同步，则可以明显提高帧数，获得更快的速度，代价就是牺牲稳定性，显卡持续高负荷运转势必发热，进而影响计算速度。
</code></pre>
<h1 id="4-屏幕坐标"><a class="header" href="#4-屏幕坐标">4. 屏幕坐标</a></h1>
<p><img src="doc/demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="Image text" />
<img src="doc/demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB-godot-1.png" alt="Image text" />
<img src="doc/demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB-godot-4%E4%B8%AA%E8%B1%A1%E9%99%90.png" alt="Image text" /></p>
<ul>
<li>刚开始学习的时候可能有点疑惑，godot的坐标系，原点既然在左上角</li>
<li>unity，cocos的2d原点都在左下角，就很符合数学里面的象限，左下角的2d坐标系感觉很复合习惯</li>
</ul>
<pre><code>后来了解到，计算机屏幕是从左上角开始刷新的，2d坐标系左上角为原点可以屏幕坐标系吻合可以提升一点效率。  

unity的2d坐标系虽然在左下角，但是unity的屏幕坐标系依然在左上角，不统一。
虽然godot的2d坐标系在左上角的坐标系刚开始看不舒服，但是和屏幕坐标系吻合了，也算一种统一，就不需要untiy2d的那么多概念了，为godot点赞。

因为单论平面内容制作，左上原点更符合视觉习惯，也更符合设计常识，比如ps。
</code></pre>
<p><img src="doc/demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB-ps.JPG" alt="Image text" /></p>
<ul>
<li>世界坐标系：又称为全局坐标系，以场景树的root节点为坐标系原点</li>
<li>相对坐标系：又称为局部坐标系或者本地坐标系，相对于父节点的坐标，godot的坐标都是相对坐标</li>
<li>屏幕坐标：屏幕的左上角为坐标系原点</li>
</ul>
<h1 id="5-全局和相对坐标的相互转化"><a class="header" href="#5-全局和相对坐标的相互转化">5. 全局和相对坐标的相互转化</a></h1>
<ul>
<li>全局坐标和局部坐标（相对坐标）可以相互转化</li>
</ul>
<pre><code>Node2D及其子节点的位置可以使用position和gloabl_position来控制。
其中，前者是该节点相对于父节点的相对位置，后者是全局位置。

简而言之，position的坐标系是以父节点的位置坐标为原点的坐标系，方向，还是水平向右为x轴正方向，竖直向下为y轴正方向。
需要注意的是，全局位置是以场景的root节点为原点的，并不是以当前场景的根结点的位置作为原点的
</code></pre>
<pre><code># 坐标点测试用例
func positionTest():
	print(position)
	print(global_position)
	print(to_global(position))
	print(to_local(global_position))
	pass
</code></pre>
<h1 id="6-深度遍历显示节点"><a class="header" href="#6-深度遍历显示节点">6. 深度遍历显示节点</a></h1>
<p><img src="doc/demo05_scene_node/image/%E5%9C%BA%E6%99%AF.png" alt="Image text" />
<img src="doc/demo05_scene_node/image/%E8%8A%82%E7%82%B9.png" alt="Image text" />
<img src="doc/demo05_scene_node/image/%E8%8A%82%E7%82%B9%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F.png" alt="Image text" /></p>
<ul>
<li>一个游戏可以包含多个场景，但是一个场景中必须有一个根节点，一个根节点可以包含多个不重名的子节点（unity的子节点可以同名），不同名更加符合习惯，为godot点赞。</li>
</ul>
<h1 id="7-sprite节点和image类的使用"><a class="header" href="#7-sprite节点和image类的使用">7. Sprite节点和Image类的使用</a></h1>
<ul>
<li>
<p>CanvasItem节点，CanvasItem -&gt; Node -&gt; Object</p>
</li>
<li>
<p>Canvas是画布的意思，所以CanvasItem代表了就是可以被绘制节点，可以设置可视化界面和材质的颜色</p>
</li>
<li>
<p>所有的2D节点和GUI节点都继承于CanvasItem节点
<img src="doc/demo05_scene_node/image/%E8%8A%82%E7%82%B9%E7%9A%84%E9%A1%BA%E5%BA%8F.png" alt="Image text" />
<img src="doc/demo05_scene_node/./image/component1.png" alt="Image text" /></p>
</li>
<li>
<p>Sprite节点，Node2d -&gt; CanvasItem -&gt; Node -&gt; Object</p>
</li>
<li>
<p>用来显示一张图片
<img src="doc/demo05_scene_node/./image/component2.png" alt="Image text" /></p>
</li>
<li>
<p>Texture类，Resource -&gt; Reference -&gt; Object</p>
</li>
<li>
<p>Texture 贴图，附加到物体表面的贴图，实际上就是包含一张Image图片</p>
</li>
<li>
<p>可以用在3D模型中当作贴图，或者2D的Sprite中当作图片，或者GUI的背景
<img src="doc/demo05_scene_node/./image/component3.png" alt="Image text" /></p>
</li>
<li>
<p>Image类，Resource -&gt; Reference -&gt; Object</p>
</li>
<li>
<p>包含了图片的数据
<img src="doc/demo05_scene_node/./image/component4.png" alt="Image text" /></p>
</li>
<li>
<p>总结
<img src="doc/demo05_scene_node/./image/component5.png" alt="Image text" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-向量的基础"><a class="header" href="#1-向量的基础">1. 向量的基础</a></h1>
<p><img src="doc/demo06_move/image/vector01.JPG" alt="Image text" />
<img src="doc/demo06_move/image/vector02.JPG" alt="Image text" />
<img src="doc/demo06_move/image/vector03.JPG" alt="Image text" />
<img src="doc/demo06_move/image/vector04.JPG" alt="Image text" />
<img src="doc/demo06_move/image/vector05.JPG" alt="Image text" />
<img src="doc/demo06_move/image/vector06.JPG" alt="Image text" />
<img src="doc/demo06_move/image/vector07.JPG" alt="Image text" />
<img src="doc/demo06_move/image/vector08.JPG" alt="Image text" /></p>
<ul>
<li>a·b=||a||||b||cosθ, 这个是向量的内积，又叫数量积，又叫点积。</li>
<li>axb = ||a||||b||sinθ，这个是向量的外积，又叫向量积，又叫叉积。</li>
</ul>
<p><img src="doc/demo06_move/image/vector11.png" alt="Image text" /></p>
<p><img src="doc/demo06_move/image/vector09.JPG" alt="Image text" />
<img src="doc/demo06_move/image/vector10.JPG" alt="Image text" /></p>
<ul>
<li>常量以godot游戏引擎为准，Vector是我从unity文档复制过来的</li>
</ul>
<h1 id="2-通过输入事件来控制物体移动"><a class="header" href="#2-通过输入事件来控制物体移动">2. 通过输入事件来控制物体移动</a></h1>
<ul>
<li>事件系统是游戏开发过程中需要涉及到交互常用的功能。</li>
<li>使用事件系统不仅可以将输入行为（例如：键盘、鼠标、触摸）以事件的形式发送到应用程序</li>
<li>也可以将游戏过程中的发生的，需要其他对象关注的事情通过事件的形式回应。例如：游戏胜利后需要打开结算或者奖励界面。</li>
</ul>
<p><img src="doc/demo06_move/image/move1.png" alt="Image text" />
<img src="doc/demo06_move/image/move2.png" alt="Image text" />
<img src="doc/demo06_move/image/move3.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-物理系统"><a class="header" href="#1-物理系统">1. 物理系统</a></h1>
<ul>
<li>物理系统（PhysicsSystem）用于管理所有物理相关的功能，目前它负责同步物理元素、触发物理事件和调度物理世界的迭代。</li>
<li>物理世界迭代时会对物理元素进行物理计算，比如计算各物体是否产生碰撞，以及物体的受力情况。当计算完成后，物理系统会将物理世界更新到场景世界中，从而使游戏对象产生相应的物理行为。</li>
<li>Godot 的物理系统提供了高效的组件化工作流程和便捷的使用方法。目前支持刚体、碰撞组件、触发和碰撞事件</li>
<li>用一句话总结物理系统，就是模拟真实世界的碰撞</li>
</ul>
<p><img src="doc/demo07_collision/image/collision-1.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-2.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-3.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-4.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-5.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-6.png" alt="Image text" /></p>
<h1 id="2-rigidbody节点"><a class="header" href="#2-rigidbody节点">2. RigidBody节点</a></h1>
<ul>
<li>刚体是组成物理世界的基本对象，你可以将刚体想象成一个你不能看到（绘制）也不能摸到（碰撞）的带有属性的物体。</li>
</ul>
<p><img src="doc/demo07_collision/image/collision-8.png" alt="Image text" /></p>
<ul>
<li>mass，刚体质量</li>
<li>weight，刚体加速度</li>
<li>linear velocity，移动速度</li>
<li>angular velocity，旋转速度</li>
<li>applied forces，施加的力</li>
<li>torque，扭矩</li>
<li>damp，衰减系数，值越大物体移动越慢，可以用来模拟空气摩擦力等效果。</li>
</ul>
<h1 id="3-刚体实战"><a class="header" href="#3-刚体实战">3. 刚体实战</a></h1>
<ul>
<li>
<p>RigidBody，动态刚体，有质量，可以设置速度，会受到重力影响。</p>
</li>
<li>
<p>Kinematic，运动刚体，零质量，可以设置速度，不会受到重力的影响，但是可以设置速度来进行移动。</p>
</li>
<li>
<p>Static，静态刚体，零质量，零速度，即不会受到重力或速度影响，但是可以设置他的位置来进行移动</p>
</li>
<li>
<p>Area2D，一块区域，能够检测到物体的碰撞，但是不会做任何操作</p>
</li>
<li>
<p>碰撞检测Layer和Mask，Layer表明当前刚体属于那一层，Mask表面当前物体的遮罩</p>
</li>
</ul>
<p><img src="doc/demo07_collision/image/collision-9.JPG" alt="Image text" />
<img src="doc/demo07_collision/image/collision-10.JPG" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-line2d-节点"><a class="header" href="#1-line2d-节点">1. Line2D 节点</a></h1>
<ul>
<li>在 2D 空间中通过几个点连成的线，可以通过代码动态添加和删除</li>
</ul>
<pre><code>注意：默认情况下，Godot一次最多只能绘制 4,096 个多边形点。
要增加这个限制，请打开项目设置，修改下面两个设置
ProjectSettings.rendering/limits/buffers/canvas_polygon_buffer_size_kb 
ProjectSettings.rendering/limits/buffers/canvas_polygon_index_buffer_size_kb。
</code></pre>
<h1 id="2-remotetransform2d-节点"><a class="header" href="#2-remotetransform2d-节点">2. RemoteTransform2D 节点</a></h1>
<ul>
<li>RemoteTransform2D，类似与设计模式中的代理模式，代理一个节点</li>
</ul>
<pre><code>RemoteTransform2D pushes its own Transform2D to another CanvasItem derived Node in the scene.

It can be set to update another Node's position, rotation and/or scale. It can use either global or local coordinates.
</code></pre>
<h1 id="3-path2d-节点"><a class="header" href="#3-path2d-节点">3. Path2D 节点</a></h1>
<ul>
<li>Path2D，包含了一个曲线路径数据</li>
</ul>
<pre><code>Contains a Curve2D path for PathFollow2D nodes to follow，Describes a Bézier curve in 2D space.
</code></pre>
<ul>
<li>PathFollow2D，要和Path2D结合在一起使用</li>
</ul>
<pre><code>This node takes its parent Path2D, and returns the coordinates of a point within it, given a distance from the first vertex.


It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be children of this node.
The descendant nodes will then move accordingly when setting an offset in this node.
</code></pre>
<h1 id="4-tilemap-节点"><a class="header" href="#4-tilemap-节点">4. Tilemap 节点</a></h1>
<ul>
<li>
<p>tilemap的由tileset组成，tileset由tile一个个单个图块组成</p>
</li>
<li>
<p>基本上通过熟练使用get_cell、set_cell、world_to_map这些函数就可以解决大多数普通关卡制作需求</p>
</li>
<li>
<p>自动填充bitmask</p>
</li>
<li>
<p>如图所示，这是一个3×3的autotile（自动图块），如果我还没有设置bitmask（位遮罩），那么此时放置图块时效果如下图所示</p>
</li>
<li>
<p>可以看到，如果没有设置bitmask，那么放置图块时只显示左上角的部分</p>
<p><img src="doc/demo08_path/image/path1.jpg" alt="Image text" />
<img src="doc/demo08_path/image/path2.gif" alt="Image text" /></p>
</li>
<li>
<p>接下来我把bitmask设置在中心区域，如图所示，接下来，我再放置autotile时，效果就不一样了，效果如下图所示：</p>
<p><img src="doc/demo08_path/image/path3.jpg" alt="Image text" />
<img src="doc/demo08_path/image/path4.gif" alt="Image text" /></p>
</li>
<li>
<p>可以看到，图中其它图块都是左上角，但中间的部分改变了，接下来我再把bitmask的范围加大，接触到相邻的图块，接下来效果就又不一样了</p>
</li>
<li>
<p>可以看到，当放置了一圈图块后，在中间添加图块时，相邻的图块全都改变了</p>
<p><img src="doc/demo08_path/image/path5.jpg" alt="Image text" />
<img src="doc/demo08_path/image/path6.gif" alt="Image text" /></p>
</li>
</ul>
<h1 id="5-navigation2d-节点"><a class="header" href="#5-navigation2d-节点">5. Navigation2D 节点</a></h1>
<ul>
<li>Navigation2D 节点可以实现自动寻路</li>
<li>目前使用最广泛的是 AStar 算法，在Godot中，Navigation2D完全的集成了此算法，让使用变得易常简单</li>
</ul>
<p><img src="doc/demo08_path/image/path7.gif" alt="Image text" /></p>
<ul>
<li>
<p>Collision 和 Navigation 。字面意思， Collision区域将是无法通过的，而Navigation可以，且寻路总是在Navigation的区域里进行。</p>
</li>
<li>
<p>引擎的作用就是为了减少大量复杂的工作，就像AStar寻路一样，在Godot中，可以非常简单的使用，就像它的函数名一样 simple 。</p>
</li>
<li>
<p>当然，游戏总不会这么简单容易，可能有非常多的情况与限制，都需要针对性处理才能满足需求。</p>
</li>
<li>
<p>参考文章 <a href="https://zhuanlan.zhihu.com/p/356255064">Navigation2D:寻路-Godot3-2D教程</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-canvasitem之draw和update"><a class="header" href="#1-canvasitem之draw和update">1. CanvasItem之draw和update</a></h1>
<ul>
<li>
<p>Canvas是画布的意思，所以CanvasItem代表了就是可以被绘制节点，可以设置可视化界面和材质的颜色
<img src="doc/demo09_canvas/image/canvas1.png" alt="Image text" /></p>
</li>
<li>
<p>所有的2D节点和GUI节点都继承于CanvasItem节点
<img src="doc/demo09_canvas/image/canvas2.png" alt="Image text" /></p>
</li>
<li>
<p>CanvasItem是按树的树的深度优先遍历顺序绘制的
<img src="doc/demo09_canvas/image/canvas3.png" alt="Image text" /></p>
</li>
<li>
<p>draw指定了要绘制的东西
<img src="doc/demo09_canvas/image/canvas4.png" alt="Image text" /></p>
</li>
<li>
<p>当要draw绘制的改变了，需要调用update
<img src="doc/demo09_canvas/image/canvas5.png" alt="Image text" /></p>
</li>
<li>
<p>hide和show，隐藏和现实节点
<img src="doc/demo09_canvas/image/canvas6.png" alt="Image text" /></p>
</li>
<li>
<p>CanvasItem可以绘制直线，正方形，长方形，圆，图片
<img src="doc/demo09_canvas/image/canvas7.png" alt="Image text" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-动画系统"><a class="header" href="#1-动画系统">1. 动画系统</a></h1>
<ul>
<li>godot中的动画其实就是一个一个图片的轮播</li>
</ul>
<pre><code>sprite解释，上世纪70年代，在德州电器公司，一个叫Daniel Hillis的前辈最早把Sprite这个词用在计算机图形上，在展示界面上，
有一些东西在实现层面并不是和整个画面融为一体的，而是『漂浮』在其他画面之上，像『幽灵』一样，所以被称为Sprite。

一张一张的图片组成了一个会动的精灵
</code></pre>
<p><img src="doc/demo10_animation/image/animation1.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation2.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation3.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation4.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation5.png" alt="Image text" /></p>
<ul>
<li>godot内置了通用的动画系统用以实现基于关键帧的动画。</li>
</ul>
<pre><code>除了支持标准的位移、旋转、缩放动画和帧动画之外，还支持任意组件属性和用户自定义属性的驱动，
再加上可任意编辑的时间曲线和创新的移动轨迹编辑功能，能够让内容生产人员不写一行代码就制作出细腻的各种动态效果。
</code></pre>
<h1 id="2-timer节点实现动画"><a class="header" href="#2-timer节点实现动画">2. Timer节点实现动画</a></h1>
<ul>
<li>
<p>Timer节点，意思是计时器秒表，在godot中可以利用他的定时器特性来实现动画帧</p>
</li>
<li>
<p>看名字就知道这是一个“计时器”。在 Godot 中一切皆节点，所以看到这种<em>纯功能性</em>的节点不要觉得奇怪</p>
</li>
<li>
<p>我们完全可以不使用节点，直接使用代码 Timer.new() 动态创建一个计时器也是没任何问题的；</p>
</li>
</ul>
<pre><code>Timer 时间计时器节点的属性非常简单，根据需求可以设置其等待时间、重复计时以及是否自动开始，这些属性我们也可以在 GDScript 脚本中使用代码修改：

wait_time ：等待时间，即计时时长，结束触发 timeout 信号
one_shot ：是否是一次性，如果是，只会触发一次 timeout 信号
autostart ：自动开始，载入场景后计时，也可以使用 start 方法手动开启
</code></pre>
<h1 id="3-tween节点实现动画"><a class="header" href="#3-tween节点实现动画">3. Tween节点实现动画</a></h1>
<ul>
<li>
<p>在游戏开发过程中，我们一般使用 AnimationPlayer 节点来实现移动、缩放、颜色渐变等动画效果</p>
</li>
<li>
<p>Tween 即<em>渐进/过渡</em>的意思，从一种状态在一定时间内变化到另一种状态，从而产生一种视觉动画。</p>
</li>
<li>
<p>渐变节点使用非常简单方便，可以对一个物体的任意属性进行动画控制，当然，也可以同时处理多个动画对象。其主要方法有以下几个：</p>
</li>
</ul>
<pre><code>repeat ：是否重复
start() ：开始渐变，结束后触发 tween_completed 信号
interpolate_property() ：设置进行动画的节点属性以及时长等，需要传递属性名称、开始结束值、时长等参数

这里最重要的方法是 interpolate_property() ，可以在 Godot 编辑器中按 F4搜索 Tween 类进行查看。
当然，和 Timer 节点一样，我们完全可以在代码中动态创建Tween 对象。


Smoothly animates a node's properties over time.

Tweens are useful for animations requiring a numerical property to be interpolated over a range of values. 
The name tween comes from in-betweening, an animation technique where you specify keyframes and the computer interpolates the frames that appear between them.

Tween is more suited than AnimationPlayer for animations where you don't know the final values in advance. 
</code></pre>
<p><img src="doc/demo10_animation/image/animation6.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation7.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation8.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation9.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation10.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation11.png" alt="Image text" /></p>
<h1 id="4-animationplayer节点实现动画"><a class="header" href="#4-animationplayer节点实现动画">4. AnimationPlayer节点实现动画</a></h1>
<ul>
<li>AnimationPlayer是时间和属性的变化，是一种动画的表现</li>
</ul>
<p><img src="doc/demo10_animation/image/animation12.png" alt="Image text" /></p>
<h1 id="5-animatedsprite节点实现动画"><a class="header" href="#5-animatedsprite节点实现动画">5. AnimatedSprite节点实现动画</a></h1>
<ul>
<li>AnimatedSprite是序列帧的简便的用法</li>
</ul>
<p><img src="doc/demo10_animation/image/animated1.png" alt="Image text" />
<img src="doc/demo10_animation/image/animated2.png" alt="Image text" />
<img src="doc/demo10_animation/image/animated3.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-光照系统light2d"><a class="header" href="#1-光照系统light2d">1. 光照系统Light2D</a></h1>
<ul>
<li>godot 的 2D 动态光照</li>
<li>首先看看 Demo 的预览效果。可以看到，当我们在 Demo 中移动光源的位置，小人和场景也会随之表现出不同光照的情景</li>
</ul>
<p><img src="doc/demo11_particle_light/image/light1.gif" alt="Image text" /></p>
<ul>
<li>带法线贴图的Sprite和普通的 Sprite 有什么区别呢? 通过对比不难看出它们的差别主要是集中在材质上面。小人使用了自定义的 mat_normal 材质</li>
</ul>
<h1 id="2-法线贴图normalmap"><a class="header" href="#2-法线贴图normalmap">2. 法线贴图NormalMap</a></h1>
<ul>
<li>法线贴图的定义</li>
</ul>
<pre><code>法线贴图就是在原物体的凹凸表面的每个点上均作法线，通过RGB颜色通道来标记法线的方向，
你可以把它理解成与原凹凸表面平行的另一个不同的表面，但实际上它又只是一个光滑的平面。
对于视觉效果而言，它的效率比原有的凹凸表面更高，若在特定位置上应用光源，可以让细节程度较低的表面生成高细节程度的精确光照方向和反射效果。
</code></pre>
<p><img src="doc/demo11_particle_light/image/light2.jpg" alt="Image text" /></p>
<pre><code>在物理世界中，我们看到的物体的颜色，其实是物体本身反射光线的颜色，因为物体的材质不同，会吸收部分不同的颜色分量而导致我们看到的物体颜色不同。

模拟光照的过程实际上就是模拟整个光的传播过程。
</code></pre>
<ul>
<li>
<p>需要注意的是，法线贴图在3D游戏中运用的更多一点，2D稍微少很多</p>
</li>
<li>
<p>法线贴图的制作软件<a href="https://github.com/azagaya/laigter">laigter</a></p>
</li>
</ul>
<p><img src="doc/demo11_particle_light/image/laigter.JPG" alt="Image text" /></p>
<ul>
<li>godot中使用法线贴图非常的简单</li>
</ul>
<p><img src="doc/demo11_particle_light/image/set-normal-map.gif" alt="Image text" />
<img src="doc/demo11_particle_light/image/light-settings.gif" alt="Image text" />
<img src="doc/demo11_particle_light/image/simple-sprite-with-normal.gif" alt="Image text" /></p>
<h1 id="3-光照和阴影lightoccluder2d"><a class="header" href="#3-光照和阴影lightoccluder2d">3. 光照和阴影LightOccluder2D</a></h1>
<ul>
<li>光照是指光的照射，godot 中光照的实现模拟了光对真实世界的影响。在场景中添加光源可以使场景产生相应的光照和阴影效果，获得更好的视觉效果。</li>
</ul>
<p><img src="doc/demo11_particle_light/image/light_shadow_main.png" alt="Image text" /></p>
<h1 id="4-粒子系统"><a class="header" href="#4-粒子系统">4. 粒子系统</a></h1>
<p><img src="doc/demo11_particle_light/image/particle.gif" alt="Image text" /></p>
<ul>
<li>粒子系统是游戏引擎特效表现的基础，它可以用于模拟的火、烟、水、云、雪、落叶等自然现象，也可用于模拟发光轨迹、速度线等抽象视觉效果。</li>
</ul>
<pre><code>中大型游戏中，几乎没有哪个游戏不使用粒子特效的。
掌握粒子系统对游戏开发极其重要，合理地使用粒子特效对游戏效果绝对是锦上添花、如虎添翼。
常见的粒子特效有：烟花、灰尘、火焰、爆炸、光环、雪花、雨滴、溅射等等等等。比如下面的这张非常熟悉的效果图，使用的就是粒子特效：
</code></pre>
<p><img src="doc/demo11_particle_light/image/particle1.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle2.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle3.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle4.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle5.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle7.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle8.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle9.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle10.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle11.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle12.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle13.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle14.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle15.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle16.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle17.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle18.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle19.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle20.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle21.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle22.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle24.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle25.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle26.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle27.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-gui系统"><a class="header" href="#1-gui系统">1. GUI系统</a></h1>
<ul>
<li>图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。</li>
</ul>
<pre><code>图形用户界面是一种人与计算机通信的界面显示格式。
允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。
与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。
图形用户界面由窗口、下拉菜单、对话框及其相应的控制机制构成，在各种新式应用程序中都是标准化的，即相同的操作总是以同样的方式来完成，
在图形用户界面，用户看到和操作的都是图形对象，应用的是计算机图形学的技术。
</code></pre>
<p><img src="doc/demo12_gui/image/gui1.png" alt="Image text" /></p>
<ul>
<li>https://docs.godotengine.org/en/3.3/getting_started/step_by_step/ui_game_user_interface.html</li>
</ul>
<h1 id="2-gui的字体选择"><a class="header" href="#2-gui的字体选择">2. GUI的字体选择</a></h1>
<ul>
<li>由于 Godot 使用 OpenGL 渲染，所以没法直接用系统字体，需要创建字体资源(Resource)，而且在 UI 组件中，默认字体没法显示中文。</li>
</ul>
<pre><code>在 Godot 中使用自定义字体的步骤如下:

复制字体文件(ttf/tts等格式)到游戏目录内
创建字体资源(DynamicFont) ， 并配置对应字体文件
控件中使用字体资源，配置字体大小，字体颜色
字体资源复用（Make Unique）
</code></pre>
<ul>
<li>
<p>godot默认不显示中文，需要下载中文的字体</p>
</li>
<li>
<p>windows自带的字体，要收费，有版权风险，C:\Windows\Fonts</p>
</li>
<li>
<p>思源黑体，免费，开源，https://github.com/adobe-fonts/source-han-sans/releases</p>
</li>
</ul>
<pre><code>由Google和Adobe在2014年7月正式推出的开源字体，
不仅可以免费商用而且全面支持中文简体、中文繁体（香港）、中文繁体（台湾）、日文和韩文，还有七种字体粗细，整个字形个数接近50万。
免费可商用
</code></pre>
<h1 id="3-gui的锚点anchor"><a class="header" href="#3-gui的锚点anchor">3. GUI的锚点Anchor</a></h1>
<ul>
<li>是一个点，锚点描述的是一个对象的Margin，相对于锚点的坐标</li>
<li>锚点的left，top，right，bottom是相对于父节点的值</li>
<li>主要是用于描述子节点相对于父节点的位置</li>
<li>当对一个节点的子节点进行设置锚点时，子节点的锚点范围只能够是父节点的控件区域内。</li>
<li>注意任何布局也都是相对于父窗口矩形的</li>
<li><strong>主要用于在GUI中描述子节点相对于父节点的位置</strong></li>
</ul>
<p><img src="doc/demo12_gui/image/gui2.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui3.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui4.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui5.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui6.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui7.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui8.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui9.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui10.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui11.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui12.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui13.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui14.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui15.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-camera2d相机"><a class="header" href="#1-camera2d相机">1. Camera2D相机</a></h1>
<ul>
<li>Godot的 Camera2D 节点，也就是我们说的摄像机，它提供了不少可以定义的属性来处理游戏中的镜头，并且非常简单。</li>
<li>摄像机的作用</li>
</ul>
<pre><code>其实不用添加摄像机，我们的游戏也能够显示出画面来，但是当移动角色时，画面并不会跟着角色移动，正好我们有一个很大的地图，要如何展示呢。

摄像机的作用就是做为屏幕可见区域的镜头，让你可以看到它照到的区域部分。当角色移动或是需要展示其它区域时，移动的就是摄像机的镜头。
</code></pre>
<ul>
<li>同一时间，只可能有一个摄像机处于激活状态。它是自动的，激活一个，其它的都会被置为未激活状态。</li>
</ul>
<p><img src="doc/demo13_camera/image/camera1.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera2.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera3.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera4.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera5.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera6.png" alt="Image text" /></p>
<h1 id="2-viewport可视化窗口实现小窗口"><a class="header" href="#2-viewport可视化窗口实现小窗口">2. Viewport可视化窗口实现小窗口</a></h1>
<ul>
<li>root就是根节点的viewport</li>
</ul>
<p><img src="doc/demo13_camera/image/viewport1.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport2.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport3.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport4.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport5.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport6.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport7.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport8.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport9.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport10.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport11.png" alt="Image text" /></p>
<h1 id="3-canvaslayer节点"><a class="header" href="#3-canvaslayer节点">3. CanvasLayer节点</a></h1>
<ul>
<li>它是一个节点, 为所有子代和孙代添加一个单独的2D渲染层.</li>
<li>Viewport的子节点默认在图层 &quot;0 &quot; 处绘制, 而CanvasLayer将在任何数字层处绘制.</li>
<li>数字较大的图层将绘制在数字较小的图层之上.CanvasLayers也有自己的变换, 不依赖于其他层的变换.</li>
<li>这使得当我们对游戏世界的观察发生变化时,UI可以固定在屏幕空间中.</li>
</ul>
<p><img src="doc/demo13_camera/image/canvaslayers.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-godot的文件系统"><a class="header" href="#1-godot的文件系统">1. godot的文件系统</a></h1>
<p><img src="doc/demo14_file/image/file1.png" alt="Image text" />
<img src="doc/demo14_file/image/file2.png" alt="Image text" /></p>
<ul>
<li>资源路径</li>
</ul>
<pre><code>访问资源时，使用主机OS文件系统布局可能很麻烦且不可移植。为了解决这个问题，创建了特殊路径 res://。
路径res://将始终指向项目根目录 (project.godot所在的位置，因此res://project.godot始终有效)
仅当从编辑器本地运行项目时，此文件系统才是读写的。
导出时或在其他设备（例如手机或控制台，或从DVD运行）上运行时，文件系统将变为只读状态，并且将不再允许写入。 
</code></pre>
<p><img src="doc/demo14_file/image/file5.png" alt="Image text" /></p>
<ul>
<li>用户路径</li>
</ul>
<pre><code>诸如保存游戏状态或下载内容包之类的任务仍需要写入磁盘。
为此，引擎确保存在始终可写的特殊路径user://。
根据项目运行所在的操作系统，此路径的解析方式有所不同。

Windows: %APPDATA%\Godot\

macOS: ~/Library/Application Support/Godot/

Linux: ~/.local/share/godot/
</code></pre>
<p><img src="doc/demo14_file/image/file6.png" alt="Image text" />
<img src="doc/demo14_file/image/file7.png" alt="Image text" /></p>
<h1 id="2-通过文件持久化游戏数据"><a class="header" href="#2-通过文件持久化游戏数据">2. 通过文件持久化游戏数据</a></h1>
<p><img src="doc/demo14_file/image/file3.png" alt="Image text" />
<img src="doc/demo14_file/image/file4.png" alt="Image text" /></p>
<h1 id="3-autoload单例模式"><a class="header" href="#3-autoload单例模式">3. autoload单例模式</a></h1>
<p><img src="doc/demo14_file/image/autoload1.png" alt="Image text" />
<img src="doc/demo14_file/image/autoload2.png" alt="Image text" />
<img src="doc/demo14_file/image/autoload3.png" alt="Image text" />
<img src="doc/demo14_file/image/autoload4.png" alt="Image text" />
<img src="doc/demo14_file/image/autoload5.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-audiostreamplayer节点播放声音"><a class="header" href="#1-audiostreamplayer节点播放声音">1. AudioStreamPlayer节点播放声音</a></h1>
<ul>
<li>AudioStreamPlayer适合用来播放BGM，AudioStreamPlayer2D、AudioStreamPlayer3D播放时声源带有位置信息，会出现左右声道不一致的问题。</li>
<li>每个AudioStreamPlayer可以将音频绑定到某一个Audio Bus中，然后直接控制Bus的音量。 例如，以下代码可以使名为Master的Bus静音。</li>
</ul>
<pre><code>AudioServer.set_bus_mute(AudioServer.get_bus_index(&quot;Master&quot;), mute)
</code></pre>
<p><img src="doc/demo15_audio/image/audio1.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio2.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio3.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio4.png" alt="Image text" /></p>
<ul>
<li>声频信号是一组数字信号，以二级制的形式存储在文件中</li>
</ul>
<p><img src="doc/demo15_audio/image/audio5.png" alt="Image text" /></p>
<ul>
<li>音频信号流就是一个声音从它的源头到输出的整一个流程，这个流程中会经历多种设备</li>
</ul>
<p><img src="doc/demo15_audio/image/audio6.png" alt="Image text" /></p>
<ul>
<li>音频混合，混音</li>
</ul>
<p><img src="doc/demo15_audio/image/audio7.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio8.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio9.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio10.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio11.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio12.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio13.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio14.png" alt="Image text" /></p>
<ul>
<li>ogg与mp3一样也是一种有损压缩的音频格式文件</li>
</ul>
<pre><code>ogg音频格式文件与其它音频不同在于它是完全免费、开放、没有专利限制的。
由于ogg格式是完全开放和免费的，所以可以获得大量的编码器和播放器，这也是为何MP3编码器如此少而且大多是商业软件的原因。
ogg文件格式可以不断地进行大小和音质的改良，而不影响旧的编码器或播放器。
</code></pre>
<ul>
<li>ogg相比MP3它可以在相对较低的数据速率下实现比MP3更好的音质</li>
</ul>
<pre><code>ogg相比MP3它可以在相对较低的数据速率下实现比MP3更好的音质
虽然目前ogg格式的音频文件在音质与MP3格式的文件相当，但由于ogg使用了一种灵活的格式，
能够在文件格式已经固定下来后还能对音质进行明显的调节和新算法训练。
此外，Ogg Vorbis支持VBR（可变比特率）和ABR（平均比特率）两种编码方式，Ogg还具有比特率缩放功能，可以不用重新编码便可调节文件的比特率。
</code></pre>
<ul>
<li>ogg格式可以对所有声道进行编码，支持多声道模式，而不像MP3只能编码双声道</li>
</ul>
<pre><code>多声道音乐会带来更多临场感，欣赏电影和交响乐时更有优势，这场革命性的变化是MP3无法支持的。
相信在未来人们对音质要求不断提高，Ogg的优势将更加明显。
支持ogg格式的播放器有很多，如winamp、千千静听等，你也可以使用转换器转换为自己喜欢的格式。
</code></pre>
<p><img src="doc/demo15_audio/image/audio15.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio16.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio17.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio18.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio19.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio21.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio22.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-http网络请求"><a class="header" href="#1-http网络请求">1. Http网络请求</a></h1>
<ul>
<li>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。</li>
</ul>
<pre><code>HTTP是应用层协议，同其他应用层协议一样，是为了实现某一类具体应用的协议，并由某一运行在用户空间的应用程序来实现其功能。
HTTP是一种协议规范，这种规范记录在文档上，为真正通过HTTP进行通信的HTTP的实现程序。

HTTP诞生之初主要是应用于WEB端内容获取，那时候内容还不像现在这样丰富，排版也没那么精美，用户交互的场景几乎没有。
</code></pre>
<p><img src="doc/demo16_http/image/http1.png" alt="Image text" />
<img src="doc/demo16_http/image/http2.png" alt="Image text" />
<img src="doc/demo16_http/image/http3.png" alt="Image text" />
<img src="doc/demo16_http/image/http4.png" alt="Image text" />
<img src="doc/demo16_http/image/http5.png" alt="Image text" />
<img src="doc/demo16_http/image/http6.png" alt="Image text" />
<img src="doc/demo16_http/image/http7.png" alt="Image text" />
<img src="doc/demo16_http/image/http8.png" alt="Image text" />
<img src="doc/demo16_http/image/http9.png" alt="Image text" />
<img src="doc/demo16_http/image/http10.png" alt="Image text" />
<img src="doc/demo16_http/image/http11.png" alt="Image text" />
<img src="doc/demo16_http/image/http12.png" alt="Image text" />
<img src="doc/demo16_http/image/http13.png" alt="Image text" />
<img src="doc/demo16_http/image/http14.png" alt="Image text" />
<img src="doc/demo16_http/image/http15.png" alt="Image text" />
<img src="doc/demo16_http/image/http16.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一设计模式六大原则"><a class="header" href="#一设计模式六大原则">一、设计模式六大原则</a></h1>
<ul>
<li>1.单一职责原则</li>
</ul>
<pre><code>一个类只负责一项职责。 
</code></pre>
<ul>
<li>2.里氏替换原则</li>
</ul>
<pre><code>所有引用父类的地方必须能透明地使用其子类的对象。

继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。
比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，
如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。

里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：
子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
子类中可以增加自己特有的方法。
</code></pre>
<ul>
<li>3.依赖倒置原则</li>
</ul>
<pre><code>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。
</code></pre>
<ul>
<li>4.接口隔离原则</li>
</ul>
<pre><code>一个类对另一个类的依赖应该建立在最小的接口上。 
接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。
</code></pre>
<ul>
<li>5.迪米特法则</li>
</ul>
<pre><code>迪米特法则又叫最少知道原则，一个对象应该对其他对象保持最少的了解。
</code></pre>
<ul>
<li>6.开闭原则</li>
</ul>
<pre><code>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
</code></pre>
<h1 id="二23种设计模式"><a class="header" href="#二23种设计模式">二、23种设计模式</a></h1>
<h2 id="1创建型模式"><a class="header" href="#1创建型模式">1.创建型模式</a></h2>
<ol>
<li>简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</li>
<li>工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。</li>
<li>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。</li>
<li>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。如StringBuilder的append()</li>
<li>单例模式：饿汉式，懒汉式，双重检测，静态内部类，枚举类实现具有天然的线程安全并且避免反射和反序列化漏洞</li>
<li>原型模式：prototype，通过复制现有的实例来创建新的实例。如深克隆，浅克隆</li>
</ol>
<h2 id="2结构型模式"><a class="header" href="#2结构型模式">2.结构型模式</a></h2>
<ol>
<li>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。如各种Adapter</li>
<li>组合模式：将对象组合成树形结构以表示的层次结构。可以理解成组合，如窗体控件，一个下滑的窗口中包含的List</li>
<li>装饰模式：动态的给对象添加新的功能。如Java的IO流</li>
<li>代理模式：为其他对象提供一个代理以便控制这个对象的访问。如静态代理，动态代理javaassist</li>
<li>亨元模式：通过共享技术来有效的支持大量细粒度的对象。</li>
<li>外观模式：facade，对外提供一个统一的方法，来访问子系统中的一群接口。</li>
<li>桥接模式：将抽象部分和它的实现部分分离，取代多层继承，多层继承违反单一职责。如DriverManager -- JDBC驱动 -- (MySQL Oracle)</li>
</ol>
<h2 id="3行为型模式"><a class="header" href="#3行为型模式">3.行为型模式</a></h2>
<ol>
<li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</li>
<li>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。如Spring的expression</li>
<li>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</li>
<li>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</li>
<li>观察者模式：对象间的一对多的依赖关系。</li>
<li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态，以便提供一个可回滚的操作。</li>
<li>中介者模式：用一个中介对象来封装一系列的对象交互。如java反射method.invoke()</li>
<li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。如执行sql语句</li>
<li>访问者模式：对于存储再一个集合中的对象，它们可能具有不同的类型，不同的访问者，其访问方式不同。</li>
<li>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</li>
<li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。如Iterator接口</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="godot-可以调用外部的ide进行脚本的编辑这里记录一下相关的配置"><a class="header" href="#godot-可以调用外部的ide进行脚本的编辑这里记录一下相关的配置">godot 可以调用外部的IDE进行脚本的编辑，这里记录一下相关的配置</a></h2>
<ul>
<li>
<p>工欲善其事必先利其器，一款好用的编辑器可以极大的提高开发效率</p>
</li>
<li>
<p>Godot 自带的代码编辑器对于代码提示使用起来比较难受、经常出现打完后不提示或者提示错误的情况，极度的不智能。</p>
</li>
<li>
<p>恰好官方就支持 VSCode 作为第三方编辑器，而且支持 Debug 调试功能，这里记录一下配置流程。</p>
</li>
<li>
<p>官方的Godot Tools插件支持断点调试，智能补全，文档查看等非常多的功能，支持比较全面</p>
</li>
<li>
<p>进入 Editor - EditorSetting - Text Editor - External，配置好 “Exec Path” 和 “Exec Flags” 后勾选 “Use External Editor”</p>
</li>
<li>
<p>vscode 编辑器设置</p>
</li>
</ul>
<pre><code>/Programs/Microsoft VS Code/Code.exe
{project} --goto {file}:{line}:{col}
</code></pre>
<ul>
<li>idea 编辑器设置</li>
</ul>
<pre><code>C:/Program Files/JetBrains/IntelliJ
{project} {file}:{line}
</code></pre>
<h2 id="使用不同版本的godot如何避免版本冲突"><a class="header" href="#使用不同版本的godot如何避免版本冲突">使用不同版本的godot如何避免版本冲突</a></h2>
<ul>
<li>
<p>在godot.exe的同级目录创建一个 .<em>sc</em> 或者 <em>sc</em> 文件，这样不同版本的godot就可以使用不同的配置了，后面godot将自动使用self-contained-mode模式</p>
</li>
<li>
<p><a href="https://docs.godotengine.org/en/latest/tutorials/io/data_paths.html#self-contained-mode">self-contained-mode官方解释</a></p>
</li>
<li>
<p><a href="https://github.com/godotengine/godot-proposals/issues/2474">参考github相关讨论</a></p>
</li>
</ul>
<h2 id="屏幕常用"><a class="header" href="#屏幕常用">屏幕常用</a></h2>
<ul>
<li>
<p>Editor | Editor Settings | Editor | Hide Console Window，设置控制台是否隐藏，3.5版本已经没有Hide Console Window这个选项了</p>
</li>
<li>
<p>Editor | Editor Settings | Run | Window Placement | Rect，设置编辑器运行游戏窗口的位置</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具准备"><a class="header" href="#工具准备">工具准备</a></h1>
<ul>
<li>python</li>
<li>SCons，项目的管理工具</li>
<li>Visual Studio 或 MinGW-w64，主要提供了C++的编译环境</li>
</ul>
<h1 id="python"><a class="header" href="#python">python</a></h1>
<ul>
<li>
<p>官网下载python，选择win64可执行的安装，左下角点击Add Path，自动添加环境变量</p>
</li>
<li>
<p>python -v ，查看版本</p>
</li>
<li>
<p>pip是python的包管理工具，python自带了pip</p>
</li>
</ul>
<pre><code>pip install requests    # 普通安装依赖
pip uninstall requests    # 卸载
pip install -r install.txt  # 从文件中批量安装依赖
pip install requests --proxy=&quot;http://127.0.0.1:10809&quot;   # 通过代理下载依赖

pip list    # 已经安装的库
pip install --upgrade requests
</code></pre>
<h1 id="scons"><a class="header" href="#scons">SCons</a></h1>
<ul>
<li>安装godot的项目依赖管理工具SCons</li>
<li>pip install SCons --proxy=&quot;http://127.0.0.1:10809&quot;</li>
<li>在命令行输入scons，看有没有反应，没有安装会提示没有这个命令</li>
</ul>
<h1 id="visual-studio"><a class="header" href="#visual-studio">Visual Studio</a></h1>
<ul>
<li>官网下载Visual Studio 2019，然后选择C++编译工具安装就行</li>
<li>如果不想安装VS，那么使用C++编译工具MinGW依然可以</li>
</ul>
<p><img src="compile/image/vs01.JPG" alt="Image text" />
<img src="compile/image/vs02.JPG" alt="Image text" />
<img src="compile/image/vs03.JPG" alt="Image text" /></p>
<h1 id="mingw-w64"><a class="header" href="#mingw-w64">MinGW-w64</a></h1>
<ul>
<li>MinGW 的全称是：Minimalist GNU on Windows</li>
<li>它实际上是将经典的开源 C语言 编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序</li>
<li>还可以使用一些 Windows 不具备的，Linux平台下的开发工具</li>
<li>一句话来概括：MinGW 就是 GCC 的 Windows 版本，MinGW-w64 是开源软件，可以免费使用</li>
<li>https://winlibs.com/ ，选择UCRT runtime下载，解压过后将bin配置在Path环境变量中，如D:\Program\mingw64\bin</li>
</ul>
<pre><code>g++ --version
clang --version
</code></pre>
<h1 id="compile"><a class="header" href="#compile">Compile</a></h1>
<ul>
<li>常规编译参数</li>
</ul>
<pre><code>scons platform=windows                # 默认去寻找VS的编译环境，找不到会寻找MinGW的编译环境
scons platform=windows use_mingw=yes  # 强制使用mingw编译
scons -j6 platform=windows            # 多线程编译
scons platform=windows bits=32        # 软件是64位还是32位置，bits=64 或者 bits=32
</code></pre>
<ul>
<li>生产版本发布，默认打包是debug+tools</li>
</ul>
<pre><code>target=release_debug
target=release          # 生产环境发布，可以加快编译速度和减小包的体积 q q
target=debug
</code></pre>
<ul>
<li>scons -j15 platform=windows target=debug tools=no
<img src="compile/image/vs05.JPG" alt="Image text" /></li>
</ul>
<pre><code>tools编辑器选项，godot里，所有带有tools的，是带编辑器的，不带tools是模板
tools可以在debug、release或者release_debug三种都可以，默认release是不带tools的
完成后，将这个打包好的exe丢到模板目录
%USERPROFILE%AppDataRoamingGodottemplates对应godot版本号
打包的文件叫godot.windows.opt.64，就把这个放入上述目录，对印的opt打包名字就改成windows_64_release
完成后就可以通过export导出项目或者将新增加的内容打包为pck作为dlc使用了
</code></pre>
<p><img src="compile/image/vs09.JPG" alt="Image text" /></p>
<ul>
<li>scons -j15 platform=windows target=release tools=no
<img src="compile/image/vs06.JPG" alt="Image text" /></li>
</ul>
<pre><code>opt是optimized production template的缩写，是优化过后的模板，这个打包更加的耗时
</code></pre>
<ul>
<li>
<p>scons -j15 platform=windows target=debug tools=yes ，等价于scons -j15 platform=windows
<img src="compile/image/vs07.JPG" alt="Image text" /></p>
</li>
<li>
<p>scons -j15 platform=windows target=release tools=yes
<img src="compile/image/vs08.JPG" alt="Image text" /></p>
</li>
<li>
<p>其它编译参数</p>
</li>
</ul>
<pre><code>scons platform=windows use_lto=yes              # MinGW的编译环境，使用这个参数可以让发布的体积更加小，但是需要更多的机器内存
</code></pre>
<h1 id="android-compile"><a class="header" href="#android-compile">Android Compile</a></h1>
<ul>
<li>增减一个环境变量，这里使用Android Studio自动下载的SDK，ANDROID_SDK_ROOT=C:\Users\jaysunxiao\AppData\Local\Android\Sdk</li>
<li>添加到Path环境变量，%ANDROID_SDK_ROOT%\tools; %ANDROID_SDK_ROOT%\platform-tools;</li>
</ul>
<pre><code>godot.windows.tools.64.exe --editor --path D:/github/godot-project-test

scons -j15 platform=windows use_mingw=yes

scons -j15 platform=android use_mingw=yes target=release android_arch=arm64v8
</code></pre>
<h1 id="使用visual-studio调试godot的源代码"><a class="header" href="#使用visual-studio调试godot的源代码">使用Visual Studio调试Godot的源代码</a></h1>
<ul>
<li>scons platform=windows vsproj=yes</li>
</ul>
<pre><code>使用命令创建vs的解决方案
</code></pre>
<ul>
<li>
<p>再使用Visual Studio双击打开sln解决方案</p>
</li>
<li>
<p>设置调试参数
<img src="compile/image/vs12.JPG" alt="Image text" /></p>
</li>
</ul>
<h1 id="使用clion调试godot的源代码"><a class="header" href="#使用clion调试godot的源代码">使用Clion调试Godot的源代码</a></h1>
<ul>
<li>
<p>使用Clion打开项目的文件（根目录）</p>
</li>
<li>
<p>Clion会让你选择一个CMake文件，选择platform/android/java/nativeSrcsConfigs/CMakeLists.txt</p>
</li>
<li>
<p>在Terminal控制台使用命令打开godot编辑器，godot.windows.tools.64.exe --editor --path D:/github/godot-project-test</p>
</li>
<li>
<p>然后Attache到godot的process</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1cU4y1o7ye/">godot C++源代码，编译，打包，调试视频教程</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用godot应该选择哪种语言gdscript-lua-c-java-rust或者c-"><a class="header" href="#使用godot应该选择哪种语言gdscript-lua-c-java-rust或者c-">使用godot应该选择哪种语言GdScript, Lua, C#, Java, Rust或者C++ ？</a></h2>
<ul>
<li>
<p>GdScript是godot亲儿子，定制化后的语言更加简单容易上手，是开源语言</p>
<ul>
<li>GDScript快速加载无需编译，无任何等待</li>
<li>GDScript没有gc，没有垃圾回收器</li>
<li>可以热更新</li>
</ul>
</li>
<li>
<p>C#由微软主导，难度稍微大一点</p>
<ul>
<li>C#需要编译和等待</li>
<li>运行的时候有gc，会导致卡顿</li>
<li>可以热更新，但是极其复杂，https://github.com/focus-creative-games/hybridclr</li>
</ul>
</li>
<li>
<p>C++大佬随意</p>
</li>
<li>
<p>Java难度稍微大一点，依赖于Jvm，https://github.com/utopia-rise/godot-kotlin-jvm</p>
</li>
<li>
<p>Rust难度非常大，语法复杂，https://github.com/godot-rust/godot-rust</p>
</li>
<li>
<p>Lua简单，https://github.com/perbone/luascript</p>
</li>
<li>
<p>JavaScript简单，https://github.com/godot-js/godot-js</p>
</li>
</ul>
<h2 id="新手如何入门一门编程语言"><a class="header" href="#新手如何入门一门编程语言">新手如何入门一门编程语言？</a></h2>
<ul>
<li>
<p>一点编程语言基础都没有的，先学Java，资料和教程多，遇到问题容易解决</p>
</li>
<li>
<p>godot是基于节点的一个游戏引擎，节点就是一个面向对象编程的思想，GdScript也是面向对象的脚本语言</p>
</li>
</ul>
<pre><code>面向对象的三个基本特征是封装、继承、多态。

所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。
</code></pre>
<ul>
<li>C++ -&gt; C -&gt; Java/C# -&gt; go -&gt;  GdScript，难度排名</li>
</ul>
<pre><code>C#资料少，遇到问题容易卡主学习者
go虽然简单，但是因为不是面向对象的，不推荐学习，godot是面向对象编程的一个游戏引擎
Cpp天生对新手不友好
</code></pre>
<ul>
<li>有一点编程基础，直接开搞，GdScript确实非常简单</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="其它比较好的doge项目实战视频教程"><a class="header" href="#其它比较好的doge项目实战视频教程">其它比较好的doge项目实战视频教程</a></h3>
<ul>
<li>https://www.bilibili.com/video/BV1pt411p7DK</li>
</ul>
<pre><code>（新手向）中文讲解Godot官方实例教程【你的第一个游戏】
</code></pre>
<ul>
<li>https://www.bilibili.com/video/BV1Rb4y1Z7r2</li>
</ul>
<pre><code>Godot游戏制作 看了必会!!! 你的第一个游戏 项目设置和Player场景制作
</code></pre>
<ul>
<li>https://www.bilibili.com/video/BV1Ei4y1m7C2</li>
</ul>
<pre><code>入门篇 005 官方文档第一个2d游戏制作（上）
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
