<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="doc/demo01_hello/download.html">Download</a></li><li class="chapter-item expanded affix "><li class="part-title">第一个程序 &gt; demo01_hello</li><li class="chapter-item expanded "><a href="doc/demo01_hello/1.hello.html"><strong aria-hidden="true">1.</strong> hello</a></li><li class="chapter-item expanded "><a href="doc/demo01_hello/2.editor.html"><strong aria-hidden="true">2.</strong> editor</a></li><li class="chapter-item expanded "><a href="doc/demo01_hello/3.node.html"><strong aria-hidden="true">3.</strong> node</a></li><li class="chapter-item expanded "><a href="doc/demo01_hello/4.sprite.html"><strong aria-hidden="true">4.</strong> sprite</a></li><li class="chapter-item expanded "><a href="doc/demo01_hello/5.node2d.html"><strong aria-hidden="true">5.</strong> node2d</a></li><li class="chapter-item expanded affix "><li class="part-title">基础知识 &gt; demo02_base</li><li class="chapter-item expanded "><a href="doc/demo02_base/base1.html"><strong aria-hidden="true">6.</strong> base1</a></li><li class="chapter-item expanded "><a href="doc/demo02_base/base2.html"><strong aria-hidden="true">7.</strong> base2</a></li><li class="chapter-item expanded affix "><li class="part-title">生命周期 &gt; demo03_lifecycle</li><li class="chapter-item expanded "><a href="doc/demo03_lifecycle/lifecycle.html"><strong aria-hidden="true">8.</strong> lifecycle</a></li><li class="chapter-item expanded affix "><li class="part-title">信号 &gt; demo04_signal</li><li class="chapter-item expanded "><a href="doc/demo04_signal/signal.html"><strong aria-hidden="true">9.</strong> signal</a></li><li class="chapter-item expanded affix "><li class="part-title">场景和节点 &gt; demo05_scene_node</li><li class="chapter-item expanded "><a href="doc/demo05_scene_node/scene_node.html"><strong aria-hidden="true">10.</strong> scene_node</a></li><li class="chapter-item expanded affix "><li class="part-title">移动对象 &gt; demo06_move</li><li class="chapter-item expanded "><a href="doc/demo06_move/move.html"><strong aria-hidden="true">11.</strong> move</a></li><li class="chapter-item expanded affix "><li class="part-title">碰撞 &gt; demo07_collision</li><li class="chapter-item expanded "><a href="doc/demo07_collision/collision.html"><strong aria-hidden="true">12.</strong> collision</a></li><li class="chapter-item expanded affix "><li class="part-title">组件 &gt; demo08_path</li><li class="chapter-item expanded "><a href="doc/demo08_path/path.html"><strong aria-hidden="true">13.</strong> path</a></li><li class="chapter-item expanded affix "><li class="part-title">画布屏幕 &gt; demo09_canvas</li><li class="chapter-item expanded "><a href="doc/demo09_canvas/canvas.html"><strong aria-hidden="true">14.</strong> canvas</a></li><li class="chapter-item expanded affix "><li class="part-title">动画 &gt; demo10_animation</li><li class="chapter-item expanded "><a href="doc/demo10_animation/animation.html"><strong aria-hidden="true">15.</strong> animation</a></li><li class="chapter-item expanded affix "><li class="part-title">粒子光 &gt; demo11_particle_light</li><li class="chapter-item expanded "><a href="doc/demo11_particle_light/particle.html"><strong aria-hidden="true">16.</strong> particle</a></li><li class="chapter-item expanded affix "><li class="part-title">图形用户界面 &gt; demo12_gui</li><li class="chapter-item expanded "><a href="doc/demo12_gui/gui.html"><strong aria-hidden="true">17.</strong> gui</a></li><li class="chapter-item expanded affix "><li class="part-title">摄像机视角 &gt; demo13_camera</li><li class="chapter-item expanded "><a href="doc/demo13_camera/camera.html"><strong aria-hidden="true">18.</strong> camera</a></li><li class="chapter-item expanded affix "><li class="part-title">文件操作 &gt; demo14_file</li><li class="chapter-item expanded "><a href="doc/demo14_file/file.html"><strong aria-hidden="true">19.</strong> file</a></li><li class="chapter-item expanded affix "><li class="part-title">音频 &gt; demo15_audio</li><li class="chapter-item expanded "><a href="doc/demo15_audio/audio.html"><strong aria-hidden="true">20.</strong> audio</a></li><li class="chapter-item expanded affix "><li class="part-title">http协议 demo16_http</li><li class="chapter-item expanded "><a href="doc/demo16_http/http.html"><strong aria-hidden="true">21.</strong> http</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="doc/design-pattern.html">设计模式</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="godot-start"><a class="header" href="#godot-start">Godot Start</a></h1>
<ul>
<li>
<p>godot engine utils and sample, example, demo, tutorial, learning, course</p>
</li>
<li>
<p>这是一个关于godot的基本使用示例和学习教程的工程项目，<a href="https://www.bilibili.com/video/BV14Y411h7Po">B站配套视频教程</a></p>
</li>
<li>
<p>godot start学习交流qq群，710511812</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="godot-start项目下载"><a class="header" href="#godot-start项目下载">godot start项目下载</a></h1>
<ul>
<li>
<p>github</p>
<ul>
<li><a href="https://github.com/zfoo-project/godot-start">https://github.com/zfoo-project/godot-start</a></li>
</ul>
</li>
<li>
<p>为了防止github时不时被墙，可以把git设置一个代理，科学上网</p>
</li>
</ul>
<pre><code>git下载代码慢的解决方法|无法下载代码的解决方法
git config --global http.proxy http://127.0.0.1:10809
git config --global https.proxy https://127.0.0.1:10809
</code></pre>
<ul>
<li>godot start学习交流群，710511812</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为什么选择godot而不选择cocos-unity-ue"><a class="header" href="#为什么选择godot而不选择cocos-unity-ue">为什么选择godot，而不选择cocos, unity, ue</a></h1>
<ul>
<li>
<p>godot比cocos, unity, ue简单，更加易上手</p>
</li>
<li>
<p>godot和cocos对比</p>
<ul>
<li>godot的源代码比cocos的源代码少一倍，所以godot源代码更加的简洁，简洁的代码更容易学习底层原理</li>
<li>cocos主要都用在2D方面，2D方面godot支持的更加全面</li>
<li>GDScript比JavaScript更加简单，因为GDScript是定制过后的语言</li>
</ul>
</li>
<li>
<p>godot和unity对比</p>
<ul>
<li>unity代码不开源，但是即使开源unity的源代码体积绝对大于godot一倍以上</li>
<li>godot安装包50M，unity安装几个g</li>
<li>目前2d方面godot优于unity，3d方面unity优于godot，godot4.0有望大大缩小和unity的差距</li>
<li>GDScript学起来也比unity的C#和Lua简单</li>
</ul>
<pre><code>大部分使用unity的开发人员都在使用Lua做开发，虽然unity官方说的是用C#，但是C#不能热更新，所以实际上工作用的大部分使用的是能够热更新的Lua
比如原神就有用到Lua来去做热更新

现在需要频繁更新的功能，比如活动，在王者荣耀中这些活动大部分都是用h5页面去做了，这个只需要JavaScript就可以了，比较完美和超前的解决方案
所以unity的语言比较杂，用C#，Lua，Javascript都有可能

GDScript兼顾性能的同时，还带来比较简洁的语法，还可以热更新。
因为godot只需要用一个GDScript语言，所以远远比unity简单
</code></pre>
</li>
<li>
<p>godot和ue对比</p>
<ul>
<li>自主可控(避免被“卡脖子”)，从开源软件的角度分析，godot是游戏引擎界的Linux，ue和unity算是Windows</li>
<li>ue虽然开源源代码，但是代码量太大，历史包袱太重，不适合深入研究底层代码的人
<img src="doc/demo01_hello/image/engine-source.PNG" alt="Image text" /></li>
</ul>
</li>
<li>
<p>godot的作者尽最大努力的减少第三方库的依赖，最终使其代码非常精简，适合学习</p>
</li>
<li>
<p>源代码开源，不收费，unity和ue都是要收费的，ue超过100万美元触发5%的分成费用
<img src="doc/demo01_hello/image/apache-license.png" alt="Image text" />
<img src="doc/demo01_hello/image/gd-home.JPG" alt="Image text" /></p>
</li>
<li>
<p>使用godot你既可以用GDScript去编写代码，也可以用C++去编写代码，还可以去改底层引擎代码</p>
</li>
<li>
<p>用godot你能感觉我能把控底层，我能把控每一行代码的底层细节，这个是程序员的浪漫，godot在国外比较火是有原因的</p>
</li>
</ul>
<h1 id="为使用godot我应该选择什么语言c-or-gdscript"><a class="header" href="#为使用godot我应该选择什么语言c-or-gdscript">为使用godot我应该选择什么语言，C# or GDScript</a></h1>
<ul>
<li>GDScript快速加载无需编译，无任何等待</li>
<li>GDScript有内置的高性能类型入Vector，更加有效率</li>
<li>GDScript多线程支持更加友好，其它脚本多线程支持很差</li>
<li>GDScript直接由godot内置引擎解析</li>
<li>GDScript没有gc，没有垃圾回收器，C#带GC垃圾回收器的语言虽然也是内存安全的，但由于GC的存在，已与底层无缘</li>
<li>gds更加简单，支持的更加完整，而且是脚本可以热更新</li>
<li>C#很多库用不了，有限制，如果是为了性能可以在godot中使用C++</li>
<li>通过学习GDScript也可以学到一些编译原理的知识</li>
<li>godot不仅仅是一个游戏引擎，而且还是一个优质的学习资源</li>
<li>C#对于godot来说比较重，推荐gds</li>
</ul>
<h3 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h3>
<ul>
<li><a href="https://www.zhihu.com/question/393440831">为什么unity愿意用c#作为代码语言,而虚幻却使用c++？</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-godot的界面介绍"><a class="header" href="#1-godot的界面介绍">1. godot的界面介绍</a></h1>
<p><img src="doc/demo01_hello/image/godot-editor.PNG" alt="Image text" /></p>
<h3 id="侧面分栏dock"><a class="header" href="#侧面分栏dock">侧面分栏（Dock）</a></h3>
<ul>
<li>
<p>点击侧面分栏的右上角可以调整分栏的位置</p>
</li>
<li>
<p>左侧面分栏具体包括：</p>
<ol>
<li>文件系统（FileSystem），显示了当前项目中所有的资源文件</li>
<li>导入（Import），显示了文件系统分栏中所选资源文件的导入设置。</li>
<li>场景（Scene），按照层级结构显示当前场景中的所有节点，可以简单的理解为一个游戏里的场景/关卡</li>
</ol>
</li>
<li>
<p>右侧面分栏具体包括：</p>
<ol>
<li>属性（Inspector），显示了场景分栏中所选节点的属性。</li>
<li>节点（Node），显示了与当前场景分栏中所选节点对应的一些“信息”。</li>
</ol>
</li>
</ul>
<h3 id="中间面板"><a class="header" href="#中间面板">中间面板：</a></h3>
<ul>
<li>
<p>主工作区（Workspace）</p>
<ul>
<li>2D，当在场景分栏中所选节点为2D类型时，会自动进入此工作区。</li>
<li>3D，当在场景分栏中所选节点为3D类型时，会自动进入此工作区。</li>
<li>脚本（Script），此工作区可以对当前项目中的脚本进行编辑。</li>
<li>资源库（AssetLib），可以搜索并浏览网站上的资源</li>
</ul>
</li>
<li>
<p>底部面板（Bottom Panel）</p>
<ul>
<li>隐藏</li>
</ul>
</li>
<li>
<p>与Unity和UE4不同的是：Godot这种布局关系当前是相对固定的，即它不能随意调整任意一个面板的位置或脱离成独立的窗口。虽然这看似是一个缺点，不过从某种程度上讲也让引擎变得更简单了。</p>
</li>
<li>
<p>如果布局乱了，恢复一下就可以了，Editor | Editor Layout | Default</p>
</li>
</ul>
<h1 id="2-场景和资源"><a class="header" href="#2-场景和资源">2. 场景和资源</a></h1>
<ul>
<li>场景 Scene ，就是一个游戏里的场景 / 关卡</li>
<li>创建场景，在res面板的文件夹下右键，New Scene创建场景</li>
<li>资源 Asset，指游戏里用到的素材、脚本等数据文件</li>
</ul>
<pre><code>比如，常用的几种类型:
Texture 图片素材  ( *.jpg /  *.png)
Audio音频素材 ( *.mp3)
程序脚本GdScript ( *.gd)
</code></pre>
<ul>
<li>可以对素材执行删除 Delete 、重命名 Rename 等操作</li>
</ul>
<h1 id="3-场景视图和游戏视图"><a class="header" href="#3-场景视图和游戏视图">3. 场景视图和游戏视图</a></h1>
<ul>
<li>
<p>场景视图Scene ，即场景编辑器窗口，默认地，创建了一个场景empty</p>
</li>
<li>
<p>鼠标滚轮 ：放大/缩小视图</p>
</li>
<li>
<p>鼠标右键拖拽：平移视图</p>
</li>
<li>
<p>网格，每一个大网格包括8*8的小网格，每个小网格8个像素</p>
</li>
</ul>
<pre><code>每一个小格子为：8像素 x 8像素
每一个大格子为：64像素 x 64像素
</code></pre>
<ul>
<li>
<p>场景视图中的蓝色框区域是可见的范围，对应的就是运行游戏的时候的游戏视图</p>
</li>
<li>
<p>本教程所有的每节课都很简单，这是因为对godot的知识做了拆解，把复杂的知识拆解为一个一个简单的知识点</p>
</li>
<li>
<p>然后把每个简单的知识点单独作为一节课，所以整个课程的难度是一种渐进式的</p>
</li>
<li>
<p>复杂的东西都是由一个一个简单的知识构成的，不要觉得课程简单，如果简单的东西不熟练不练习，后面的课程很可能会更不上</p>
</li>
</ul>
<h1 id="4-游戏对象节点"><a class="header" href="#4-游戏对象节点">4. 游戏对象（节点）</a></h1>
<ul>
<li>
<p>游戏对象 Node，就是场景中包含的内容，godot所有操作都是基于节点Node</p>
</li>
<li>
<p>演示：向Scene窗口里添加几个图片</p>
</li>
</ul>
<pre><code>1 准备图片素材
2 把图片拖到2D游戏场景中
3 在Scene窗口中，观察新加的游戏对象
</code></pre>
<ul>
<li>游戏对象的简单操作：</li>
</ul>
<pre><code>1 选中游戏对象
从左侧的层次管理器（Scene窗口）中选中游戏对象
2 移动游戏对象
选用移动工具，拖动小方块
3 修改对象名字
在Scene窗口中，可以修改名字、删除对象等操作
</code></pre>
<h1 id="5-坐标系"><a class="header" href="#5-坐标系">5. 坐标系</a></h1>
<p><img src="doc/demo01_hello/../demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB-godot-1.png" alt="Image text" /></p>
<ul>
<li>选择移动工具，移动一个对象</li>
<li>可以通过鼠标去移动游戏对象，也可以通过键盘方向键移动游戏对象，也可以手动修改position的坐标x和y去更加精确的移动对象</li>
</ul>
<pre><code>在 Inspector 属性面板：
观察对象的坐标 Position: x,  y
可以发现，对象的坐标会随之变化
</code></pre>
<ul>
<li>世界坐标系，又称为全局坐标系</li>
</ul>
<pre><code>y轴向下为正
x轴向右为正

一个像素在真实世界中，可以自行约定，比如约定1像素=1米
</code></pre>
<ul>
<li>
<p>相对坐标系，又称为局部坐标系或者本地坐标系，相对于父节点的坐标，godot的坐标都是相对坐标</p>
</li>
<li>
<p>全局坐标和局部坐标可以相互转化</p>
</li>
</ul>
<pre><code>Node2D及其子节点的位置可以使用position和gloabl_position来控制，其中，前者是该节点相对于父节点的相对位置，后者是全局位置。
简而言之，position的坐标系是以父节点的位置坐标为原点的坐标系，方向，还是水平向右为x轴正方向，竖直向下为y轴正方向。
需要注意的是，全局位置是以场景的左上角为原点的，并不是以根结点的位置作为原点的
</code></pre>
<h1 id="6-节点的基础操作"><a class="header" href="#6-节点的基础操作">6. 节点的基础操作</a></h1>
<ul>
<li>Q，选择工具，最强大的工具</li>
</ul>
<pre><code>Alt + 拖曳边框缩放点，保持选中目标中心位置不变进行缩放
Shift + 等比列缩放
Ctrl + 鼠标拖曳，以pivot为中心旋转当前对象
</code></pre>
<ul>
<li>W，移动工具，改变 Position</li>
</ul>
<pre><code>Move Mode 对象的移动：
单独改变X坐标
单独改变Y坐标
拖拽中间的方块，可以任意拖动
也可以直接在 Inspector 中输入坐标，会更精确一些
</code></pre>
<ul>
<li>R，旋转工具，改变 Rotation</li>
</ul>
<pre><code>轴心点，又称中心点，是节点的旋转中心

V，移动轴心点，Shift + V 拖拽轴心点

中心点是一个物体的中心，当我们对物体进行操作的时候，都是以中心点为中心进行对物体的操作
轴心点可以理解为把物体抽象成一个点，物体的位置就是指其轴心点的位置，就是该物体坐标系的原点
后面的课程会继续介绍轴心点

Rotate Mode 对象的旋转
沿轴心点旋转
</code></pre>
<ul>
<li>S，缩放工具，改变 Scale</li>
</ul>
<pre><code>Scale Mode 对象的缩放
沿 X 轴缩放
沿 Y 轴缩放
拖拽中间的小方块，X 和 Y 等比例缩放
</code></pre>
<ul>
<li>F，居中选取对象，非常有用的快捷键</li>
</ul>
<h1 id="7-节点操作的工具多节点选择轴心点平滑尺子"><a class="header" href="#7-节点操作的工具多节点选择轴心点平滑尺子">7. 节点操作的工具，多节点选择，轴心点，平滑，尺子</a></h1>
<ul>
<li>多节点选择工具，show a list，主要用来精确选择层叠在一起的节点</li>
<li>轴心点工具，移动轴心点，和选择工具中的快捷键V有同样的作用</li>
<li>平滑工具，固定场景</li>
<li>尺子工具，量图片或者节点的像素</li>
</ul>
<h1 id="8-智能对齐snap和锁定节点"><a class="header" href="#8-智能对齐snap和锁定节点">8. 智能对齐Snap和锁定节点</a></h1>
<ul>
<li>智能对齐，Smart Snap</li>
<li>网格对齐，Grid Snap</li>
<li>锁定节点，使其不能移动</li>
<li>子节点不可选中</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-节点的父子关系"><a class="header" href="#1-节点的父子关系">1. 节点的父子关系</a></h1>
<ul>
<li>
<p>在层级树中，对象 (节点) 呈树形显示，一个节点下面，也可以下挂子节点</p>
</li>
<li>
<p>演示：</p>
</li>
</ul>
<pre><code>1 添加两个对象
2 拖拽一个对象到另一个对象，成为子对象 (子节点)
3 移动父对象、旋转父对象，观察

可以发现，当父对象移动时，子对象随之移动
</code></pre>
<ul>
<li>理解相对坐标</li>
</ul>
<pre><code>子对象的坐标轴，是相对于父对象的
1 移动父对象时，子对象的 Position 不发生变化
2 旋转父对象时，子对象的 Rotation 不发生变化
</code></pre>
<h1 id="2-节点的显示和隐藏"><a class="header" href="#2-节点的显示和隐藏">2. 节点的显示和隐藏</a></h1>
<ul>
<li>删除游戏对象</li>
</ul>
<pre><code>右键 Delete ，或者键盘 Delete 均可
</code></pre>
<ul>
<li>恢复</li>
</ul>
<pre><code>CTRL + Z ，撤销上一步操作
</code></pre>
<ul>
<li>更改节点对象名字</li>
</ul>
<pre><code>右键 Rename，或者双击节点修改
</code></pre>
<ul>
<li>显示 / 隐藏</li>
</ul>
<pre><code>在 Inspector 里，勾选 Visible 复选框，或者在节点右侧点击Toggle Visibility
</code></pre>
<ul>
<li>设置长宽比</li>
</ul>
<pre><code>在 Project | Project Settings | Display | Window 中可以设置长宽比
</code></pre>
<h1 id="3-游戏节点的显示顺序"><a class="header" href="#3-游戏节点的显示顺序">3. 游戏节点的显示顺序</a></h1>
<ul>
<li>在2D画面中，两个对象如果重叠，谁显示在上面呢？</li>
<li>按照节点的顺序</li>
<li>在数据结构上的专业术语叫树的深度优先遍历，深度优先遍历的顺序就是最后显示的顺序</li>
</ul>
<p><img src="doc/demo01_hello/../demo05_scene_node/image/%E8%8A%82%E7%82%B9.png" alt="Image text" />
<img src="doc/demo01_hello/../demo05_scene_node/image/%E8%8A%82%E7%82%B9%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F.png" alt="Image text" /></p>
<h1 id="4-pivot轴心点"><a class="header" href="#4-pivot轴心点">4. pivot，轴心点</a></h1>
<ul>
<li>
<p>轴心点也叫中心点，中心点是一个物体的中心，当我们对物体进行操作的时候，都是以中心点为中心进行对物体的操作</p>
</li>
<li>
<p>轴心点可以理解为把物体抽象成一个点，物体的位置就是指其轴心点的位置，就是该物体坐标系的原点</p>
</li>
<li>
<p><strong>主要用于旋转和决定对象的位置</strong></p>
</li>
<li>
<p>轴心 Pivot ，指旋转轴、坐标基准点，默认在对象的几何中心</p>
</li>
<li>
<p>轴心的作用：</p>
<ul>
<li>旋转轴，当旋转对象时，是以 Pivot 为轴心来去旋转对象的</li>
<li>坐标系的原点，当移动对象时，是以 Pivot 为中心来计算位置Position的</li>
</ul>
</li>
<li>
<p>添加一个图片，设置其 Pivot 位置，多练习一下，不及小步无以至千里</p>
</li>
</ul>
<h1 id="5-anchor锚点"><a class="header" href="#5-anchor锚点">5. anchor，锚点</a></h1>
<ul>
<li>是一个点，锚点描述的是一个对象的Margin，相对于锚点的坐标</li>
<li>锚点的left，top，right，bottom是相对于父节点的值</li>
<li>主要是用于描述子节点相对于父节点的位置</li>
<li>当对一个节点的子节点进行设置锚点时，子节点的锚点范围只能够是父节点的控件区域内。</li>
<li>注意任何布局也都是相对于父窗口矩形的</li>
<li><strong>主要用于在GUI中描述子节点相对于父节点的位置</strong></li>
<li>后面的课程学到GUI中会继续介绍锚点，现在只做了解</li>
</ul>
<p><img src="doc/demo01_hello/../demo12_gui/image/gui4.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui5.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui6.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui7.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui8.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui9.png" alt="Image text" />
<img src="doc/demo01_hello/../demo12_gui/image/gui10.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-图片素材的准备"><a class="header" href="#1-图片素材的准备">1. 图片素材的准备</a></h1>
<ul>
<li>
<p>术语：Sprite 精灵，游戏开发中指一张图片</p>
</li>
<li>
<p>来源不明的图片，切勿在商业用途使用，以免引起版权风险。做一个遵纪守法的好公民。</p>
</li>
</ul>
<pre><code>1. 在学习阶段，可以百度或者从一些资源网站获取，这种方式只能用在学习交流但是无法商用
2. 在正式工作时，公司会有专门的美术人员提供素材
3. 比较大的资源素材商店是是Unity Store
4. 独立开发者可以外包给第三方团队完成
5. 可以从一些素材网站获取正版授权的图片素材，还有一些免版权的网站一样可以获取到
6. 到一些个人外包网站如万能的淘宝或者猪八戒网，外包给大学生或其他找副业赚钱的人
</code></pre>
<ul>
<li>
<p>推荐几个国外比较好的资源网站，国内的资源网站现在还比较稀缺，需要科学上网</p>
<ul>
<li><a href="https://assetstore.unity.com/">Untiy Store</a> ，最大的游戏资源网站，可以使用里面的2D图片资源</li>
<li><a href="https://craftpix.net/">craftpix</a> ，国外的一家提供高品质的优质和免费的2D游戏资产的网站</li>
<li><a href="https://www.gamedevmarket.net/">game dev market</a> ，内容涉及2D、3D、音频和GUI素材，也可以作为一个寻找素材的补充</li>
<li><a href="https://kenney.nl/">kenney</a> ，国外一家做游戏创意原型的资源站</li>
<li><a href="https://www.fiverr.com/">Fiverr</a> ，一个综合的数字服务提供平台，可以直接在里面找到为我们工作的人，然后他们会提供一些我们定制的服务。</li>
</ul>
</li>
<li>
<p>一般人很难即精通程序也精通美术，这两种的思维方式不一样。上帝为你打开了一扇门，他同时也很可能关闭了一扇窗户</p>
</li>
<li>
<p>2D 图片的要求：</p>
</li>
</ul>
<pre><code>1 背景图片，一般为 JPG
2 人物、道具等其他图片，一般为PNG ，背景透明
</code></pre>
<ul>
<li>演示：PS处理一张图片，去掉背景，做成可用的素材</li>
</ul>
<h1 id="2-图片的切割"><a class="header" href="#2-图片的切割">2. 图片的切割</a></h1>
<ul>
<li>
<p>一个 PNG 图片中，可能包含多个素材，使用时需要切割一下</p>
<ul>
<li>第一种方式，将图片用ps之类的工具切割好以后，重新导入godot中使用</li>
<li>第二种方式，导入godot中通过Region指定使用的图片，做间接切割</li>
</ul>
</li>
<li>
<p>一个图片未经切割时，则只包含一个 Sprite素材</p>
</li>
</ul>
<h1 id="3-图片的合并"><a class="header" href="#3-图片的合并">3. 图片的合并</a></h1>
<ul>
<li>
<p>有时图片太多不好管理，想合并成一整张图片去使用</p>
<ul>
<li>第一种方式，将图片用ps之类的工具合并好以后，重新导入godot中使用</li>
<li>第二种方式，在godot中选中多张资源，然后已AtlasTexture的方式重写reimport</li>
</ul>
</li>
<li>
<p>重写reimport导入过后，也可以把之前的图片删除掉，已节省游戏的包体积和目录文件</p>
</li>
</ul>
<h1 id="4-图片与渲染器"><a class="header" href="#4-图片与渲染器">4. 图片与渲染器</a></h1>
<ul>
<li>
<p>godot是基于节点的，节点有不同的种类，不同种类的节点代表了不同的功能</p>
</li>
<li>
<p>Sprite节点继承于Node2D节点，所以包含Node2D节点的所有属性</p>
</li>
<li>
<p>Sprite节点，用于显示一个Sprite，把一张图片渲染出来</p>
</li>
<li>
<p>节点的种类表示一种功能，而 Sprite 的功能就是显示图片，后面还会说</p>
</li>
<li>
<p>演示和练习：</p>
</li>
</ul>
<pre><code>1 添加一个对象，显示图片1
2 观察 Sprite 的属性值
3 让 Sprite Renderer 更换显示另一张图片，通过拖拽方式或者通过选择文件的方式
4 通过创建一个节点的方式创建Sprite节点
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-节点和功能的关系"><a class="header" href="#1-节点和功能的关系">1. 节点和功能的关系</a></h1>
<ul>
<li>
<p>节点 Node ，用于实现一种功能，例如，Sprite 节点，用于图片的显示</p>
</li>
<li>
<p>一个节点的功能取决于它挂载了哪些子节点，它包含了哪些功能的子节点，就包含了对应子节点表示的功能</p>
</li>
<li>
<p>节点是可选的，可以添加、可以删除</p>
</li>
<li>
<p>先创建一个空的节点，再选择需要的节点</p>
</li>
</ul>
<p><img src="doc/demo01_hello/image/node2d-00.JPG" alt="Image text" /></p>
<pre><code>Sprite用来显示一张图片，再给Sprite增加一个刚体

演示：
1 添加一个空的节点Node
2 挂载 Sprite 节点，然后再挂载RigidBody2D刚体节点
3 移除RigidBody2D刚体节点
</code></pre>
<h1 id="2-node节点"><a class="header" href="#2-node节点">2. Node节点</a></h1>
<ul>
<li>Node节点，是基类节点，所有节点都会继承Node节点，所以其它类型都包含Node节点的功能</li>
<li>Node节点是最核心的节点，所有其他类型节点都是由Node节点派生出来的</li>
</ul>
<p><img src="doc/demo01_hello/image/node2d-01.JPG" alt="Image text" /></p>
<pre><code>1. Pause Mode节点的暂停
get_tree().paused = true
节点的三种可能状态有:

Inherit（继承） ：处理与否取决于父、祖父等等节点中第一个非 Inherit 状态的节点。
Stop（停止） ：无条件停止节点（以及 Inherit 模式的子节点）。暂停时该节点不会进行处理。
Process（处理） ：无条件处理节点（以及 Inherit 模式的子节点）。无论暂停与否，该节点都会进行处理。

process方法执行的优先级，对于子节点依然有效

挂载外部的脚本

</code></pre>
<pre><code># 脚本初始化会首先调用这个方法，会在_process()方法之前调用
func _ready():
	# get_tree().paused = true
	pass

var count = 0
# 每一帧都会调用这个方法
func _process(delta):
	count = count + 1
	
	if (count % 60 == 0):
		print(&quot;parent node&quot;)
	pass
</code></pre>
<h1 id="3-canvasitem节点"><a class="header" href="#3-canvasitem节点">3. CanvasItem节点</a></h1>
<ul>
<li>
<p>CanvasItem节点，CanvasItem -&gt; Node</p>
</li>
<li>
<p>Canvas是画布的意思，所以CanvasItem代表了就是可以被绘制节点，可以设置可视化界面和材质的颜色</p>
</li>
<li>
<p>所有的2D节点和GUI节点都继承于CanvasItem节点</p>
</li>
<li>
<p>CanvasItem是按树的树的深度优先遍历顺序绘制的</p>
</li>
<li>
<p>可以通过设置CanvasItem的Show Behind Parent来改变最终渲染到屏幕上的画面顺序</p>
</li>
</ul>
<pre><code>Texture 贴图，附加到物体表面的贴图
Material 材质，物体的质地，指色彩，纹理，光滑度，透明度，反射率，折射率，发光度。实际就是Shader
Shader 着色器，使用代码来渲染图形的技术，可以控制GPU运算图像效果的一段代码
</code></pre>
<h1 id="4-node2d节点"><a class="header" href="#4-node2d节点">4. Node2D节点</a></h1>
<ul>
<li>Node2D节点，Node2d -&gt; CanvasItem -&gt; Node</li>
</ul>
<pre><code>Node2D节点继承于CanvasItem节点，CanvasItem节点继承于Node节点，所以Node2D节点包括了CanvasItem节点和Node节点的所有功能

Transform ，Node2d节点的基本属性，在后面的脚本编程中，Transform属性是最常用的
表示：
 - Position 位置
 - Rotation 旋转
 - Scale 缩放
</code></pre>
<h1 id="5-自定义节点"><a class="header" href="#5-自定义节点">5. 自定义节点</a></h1>
<ul>
<li>
<p>当发现现有的节点无法支持新的需求的时候，有两种方法去解决，自定义节点或者自定义脚本，核心都是脚本</p>
</li>
<li>
<p>创建GdScrip脚本，叫MyNode，继承Node2D节点，并自定义节点的icon</p>
</li>
</ul>
<pre><code>extends Node2D

class_name MyNode, &quot;res://icon.png&quot;
</code></pre>
<ul>
<li>编写脚本，定义变量，编写代码</li>
</ul>
<pre><code>export var a = 1
export var b:String
</code></pre>
<ul>
<li>
<p>保存，如果不保存无法看到我们创建到的节点，这一点需要特别注意</p>
</li>
<li>
<p>添加刚刚创建的自定义节点</p>
</li>
</ul>
<h1 id="6-节点继承"><a class="header" href="#6-节点继承">6. 节点继承</a></h1>
<ul>
<li>通过继承现有节点，来改变已有节点的功能</li>
<li>无论是自定义节点还是节点继承，核心都通过脚本控制达到自己想要的效果</li>
<li>从下节课开始说GdScript脚本</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-脚本的定义"><a class="header" href="#1-脚本的定义">1. 脚本的定义</a></h1>
<ul>
<li>游戏脚本 Script ，用代码来控制游戏对象</li>
<li>godot使用 GdScript 作为脚本语言</li>
<li>注意：自本章开始，每节课的项目源码都放在了github项目godot-start，可以直接对照示例项目</li>
<li>游戏开发，也是一种程序设计，如果是0基础的同学，建议先学习一个强类型语言比如Java，C#，C++，再来学习GdScript就一通百通了</li>
</ul>
<h1 id="2-脚本的使用"><a class="header" href="#2-脚本的使用">2. 脚本的使用</a></h1>
<ul>
<li>如何使用一个脚本？</li>
</ul>
<pre><code>新建脚本 hello.gd ，编辑代码 ，保存一下
把脚本挂载到游戏节点上
运行游戏，点 Play Scene 运行当前游戏场景，在 Output 窗口里观察打印输出
</code></pre>
<h1 id="3-认识脚本"><a class="header" href="#3-认识脚本">3. 认识脚本</a></h1>
<ul>
<li>因为是GdScript是弱类型语言，所以比较自由，但是我们可以约定一些原则让代码更加的规范：</li>
</ul>
<pre><code>类名必须与文件名相同，且为小写
尽量继承于 Node2D 节点，Node2D 节点中的Transform是我们用的最多的节点
</code></pre>
<ul>
<li>常用函数内部执行顺序，_init  _ready  _process</li>
</ul>
<pre><code>默认定义了一些事件函数，例如，
  _init()  脚本初始化的时候调用，对象的构造器，类似于Java的构造函数construct
  _ready()  开始调用一次，可用于初始化脚本
  _process(delta) 每帧调用，帧间隔不等，可用于更新游戏
</code></pre>
<h1 id="4变量和数据类型"><a class="header" href="#4变量和数据类型">4.变量和数据类型</a></h1>
<ul>
<li>变量是用于存储信息的&quot;容器&quot;。</li>
</ul>
<pre><code>var x=5;
var y=6;
var z=x+y;

就像代数那样
x=5
y=6
z=x+y

在代数中，我们使用字母（比如 x）来保存值（比如 5）。
通过上面的表达式 z=x+y，我们能够计算出 z 的值为 11。
在 godot 中，这些字母被称为变量。
</code></pre>
<ul>
<li>gds数据类型分类
<ul>
<li>bool，一个字节，默认为false</li>
<li>int(同C++和Java long)，8个字节，默认为0</li>
<li>float(同C++和Java double)，8个字节，默认为0</li>
<li>String，默认为null，字符串可以存储一系列字符，如 &quot;John Doe&quot;。</li>
<li>数组</li>
<li>对象</li>
<li>null，变量没有被赋值，则默认为null</li>
</ul>
</li>
</ul>
<p><img src="doc/demo02_base/image/integer.JPG" alt="Image text" />
<img src="doc/demo02_base/image/integer_overflow.JPG" alt="Image text" />
<img src="doc/demo02_base/image/step.JPG" alt="Image text" /></p>
<h1 id="5导出变量"><a class="header" href="#5导出变量">5.导出变量</a></h1>
<ul>
<li>export关键字可以让变量在编辑器中编辑</li>
</ul>
<pre><code># 导出一个数字
export var a = 1
# 导出一个节点路径
export var b:NodePath
# 导出一个节点路径，不同的写法
export(NodePath) var c
# 导出一个文件路径
export(String, FILE) var e 
# 导出一个文件路径，以txt结尾
export(String, FILE, &quot;*.txt&quot;) var d
# 导出一个资源文件路径
export(Resource) var f
# 导出一个颜色
export(Color, RGB) var g
</code></pre>
<h1 id="6函数"><a class="header" href="#6函数">6.函数</a></h1>
<ul>
<li>函数是可以简单的理解为当它被调用时执行的可重复使用的代码块。</li>
<li>函数就是包裹在花括号中的代码块，前面使用了关键词 func，当调用该函数时，会执行函数内的代码。</li>
<li>空函数需要使用pass关键字</li>
</ul>
<pre><code>func sayHello():
    # 执行代码
</code></pre>
<ul>
<li>调用带参数的函数，在调用函数时，您可以向其传递值，这些值被称为参数。</li>
</ul>
<pre><code>func sayHello(param1， param2):
    # 执行代码
</code></pre>
<ul>
<li>带有返回值的函数，有时，我们会希望函数将值返回调用它的地方，通过使用 return 语句就可以实现。</li>
<li>return方法可以指定返回的类型</li>
</ul>
<pre><code>func sayHello(param1， param2):
    # 执行代码
    return x
</code></pre>
<h1 id="7变量的作用域"><a class="header" href="#7变量的作用域">7.变量的作用域</a></h1>
<ul>
<li>局部作用域，变量在函数内声明，变量为局部作用域，只能在函数内部访问</li>
</ul>
<pre><code># 此处不能调用 carName 变量
func myFunction():
    var carName = &quot;Volvo&quot;;
    # 函数内可调用 carName 变量
</code></pre>
<ul>
<li>全局变量，变量在函数外定义，即为全局变量，整个脚本文件中都可以使用</li>
</ul>
<pre><code>var carName = &quot; Volvo&quot;;
 
# 此处可调用 carName 变量
func myFunction():
    # 函数内可调用 carName 变量
</code></pre>
<h1 id="8-运算符"><a class="header" href="#8-运算符">8. 运算符</a></h1>
<ul>
<li>算术运算符</li>
</ul>
<pre><code>+	加法	        x=y+2	7	5
-	减法	        x=y-2	3	5
*	乘法	        x=y*2	10	5
/	除法	        x=y/2	2.5	5
%	取模（余数）	x=y%2	1	5
</code></pre>
<ul>
<li>赋值运算符，赋值运算符用于给 GdScript 变量赋值</li>
</ul>
<pre><code>=	x=y	 	x=5
+=	x+=y	x=x+y	x=15
-=	x-=y	x=x-y	x=5
*=	x*=y	x=x*y	x=50
/=	x/=y	x=x/y	x=2
%=	x%=y	x=x%y	x=0
</code></pre>
<ul>
<li>比较运算符，比较运算符在逻辑语句中使用，以测定变量或值是否相等</li>
</ul>
<pre><code>==	等于	x==8	false
!=	 不等于	x!=8	true
&gt;	 大于	x&gt;8	false
&lt;	 小于	x&lt;8	true
&gt;=	 大于或等于	x&gt;=8	false
&lt;=	 小于或等于	x&lt;=8	true
</code></pre>
<ul>
<li>逻辑运算符，逻辑运算符用于测定变量或值之间的逻辑。</li>
</ul>
<pre><code>&amp;&amp;	and	(x &lt; 10 &amp;&amp; y &gt; 1) 为 true
||	or	(x==5 || y==5) 为 false
!	not	!(x==y) 为 true
</code></pre>
<h1 id="9-条件语句"><a class="header" href="#9-条件语句">9. 条件语句</a></h1>
<ul>
<li>
<p>通常在写代码时，您总是需要为不同的决定来执行不同的动作。您可以在代码中使用条件语句来完成该任务。</p>
</li>
<li>
<p>if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码</p>
</li>
</ul>
<pre><code>if (condition):
    当条件为 true 时执行的代码
</code></pre>
<ul>
<li>if...else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li>
</ul>
<pre><code>if (condition):
    当条件为 true 时执行的代码
else:
    当条件不为 true 时执行的代码
</code></pre>
<ul>
<li>if...else if....else 语句- 使用该语句来选择多个代码块之一来执行</li>
</ul>
<pre><code>if (condition1):
    当条件 1 为 true 时执行的代码
else if (condition2):
    当条件 2 为 true 时执行的代码
else:
  当条件 1 和 条件 2 都不为 true 时执行的代码
</code></pre>
<ul>
<li>match(switch) 语句 - 使用该语句来选择多个代码块之一来执行</li>
</ul>
<h1 id="10-循环语句"><a class="header" href="#10-循环语句">10. 循环语句</a></h1>
<ul>
<li>循环可以将代码块执行指定的次数，如果您希望一遍又一遍地运行相同的代码，并且每次的值都不同，那么使用循环是很方便的</li>
<li>for</li>
<li>while</li>
<li>break 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）</li>
<li>continue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代</li>
</ul>
<h1 id="11-数组和字典的遍历"><a class="header" href="#11-数组和字典的遍历">11. 数组和字典的遍历</a></h1>
<ul>
<li>数组遍历</li>
</ul>
<pre><code>func arrayIterator():
	# range等价于for(int i = 0; i &lt; 20; i++)
	print(&quot;数组遍历方法1：&quot;)
	for i in range(3):
		print(i)
	print(&quot;数组遍历方法2：&quot;)
	for ele in arr:
		print(ele)
	print(&quot;数组遍历方法3：&quot;)
	for index in range(arr.size()):
		print(arr[index])
</code></pre>
<ul>
<li>字典遍历</li>
</ul>
<pre><code>func dictionaryIterator():
	print(&quot;字典遍历方法1：&quot;)
	for key in dict:
		print(&quot;key:&quot; + key as String)
		print(&quot;value:&quot; + dict[key] as String)
		
	print(&quot;字典遍历方法2：&quot;)
	for key in dict.keys():
		print(&quot;key:&quot; + key as String)
		print(&quot;value:&quot; + dict[key] as String)
		
	print(&quot;字典遍历方法3：&quot;)
	for value in dict.values():
		print(&quot;value:&quot; + value as String)	
</code></pre>
<h1 id="12-静态变量和静态方法"><a class="header" href="#12-静态变量和静态方法">12. 静态变量和静态方法</a></h1>
<ul>
<li>const变量（静态变量）</li>
</ul>
<pre><code>const ANSWER = 42
</code></pre>
<ul>
<li>静态方法</li>
</ul>
<pre><code>static func getAnswer():
	return ANSWER
</code></pre>
<h1 id="13-对象"><a class="header" href="#13-对象">13. 对象</a></h1>
<ul>
<li>真实生活中的对象，属性和方法</li>
<li>真实生活中，一辆汽车是一个对象。对象有它的属性，如重量和颜色等，方法有启动停止等</li>
</ul>
<pre><code># Inner class，默认继承Object
class Animal:
	extends Object  # 如果不指定继承的类，默认基础Object
	const STATIC_FIELD = &quot;静态变量&quot;
	# 属性
	var height: int
	
	func _init():
		print(&quot;Animal 构造方法&quot;)
		
	func move():
		print(&quot;animal，移动&quot;)
	
	static func staticFuction():
		pass
</code></pre>
<h1 id="14-调试"><a class="header" href="#14-调试">14. 调试</a></h1>
<ul>
<li>在编写 GdScript 时，如果没有调试工具将是一件很痛苦的事情。</li>
<li>你的代码可能包含语法错误，逻辑错误，有了调试工具，这些错误比较容易发现。</li>
</ul>
<h1 id="15-参考资料"><a class="header" href="#15-参考资料">15. 参考资料</a></h1>
<ul>
<li><a href="https://docs.godotengine.org/en/stable/getting_started/scripting/gdscript/gdscript_basics.html">godot官方文档</a></li>
<li><a href="https://www.youtube.com/watch?v=JJQa3xrRNM0&amp;list=PLJ690cxlZTgL4i3sjTPRQTyrJ5TTkYJ2_">Godot Tutorials的GDScript Fundamentals Tutorial Series，youtube播放量最高的godot教程视频</a></li>
<li><a href="https://www.youtube.com/watch?v=sChM51ibm5k&amp;list=PLJ690cxlZTgIsmdEhFufnB7O6KWoMS8M6">Godot Tutorials的Godot Basics Tutorial Series，youtube播放量最高的godot教程视频</a></li>
<li><a href="https://www.bilibili.com/video/BV17g4y1z7uS">B站视频</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-内存管理free"><a class="header" href="#1-内存管理free">1. 内存管理free</a></h1>
<ul>
<li>
<p>godot中的对象分为两种</p>
<ul>
<li>引用计数对象，继承于Reference，当没有引用时会被自动回收</li>
<li>非引用计数对象，没有继承于Reference，自能自己手动回收,free或queue_free</li>
</ul>
</li>
<li>
<p>在godot中，移除一个节点并不会从节点中删除，必须手动调用free或queue_free</p>
</li>
</ul>
<p><img src="doc/demo02_base/image/gc.JPG" alt="Image text" /></p>
<h1 id="2-垃圾回收的缺点"><a class="header" href="#2-垃圾回收的缺点">2. 垃圾回收的缺点</a></h1>
<p><img src="doc/demo02_base/image/gc1.png" alt="Image text" />
<img src="doc/demo02_base/image/gc2.png" alt="Image text" />
<img src="doc/demo02_base/image/gc3.png" alt="Image text" /></p>
<ul>
<li>GdScript没有垃圾回收，虽然有着内存泄露的风险，但是也保证了性能</li>
</ul>
<h1 id="3-引用计数算法"><a class="header" href="#3-引用计数算法">3. 引用计数算法</a></h1>
<ul>
<li>
<p>对于创建的每一个对象都有一个与之关联的计数器，这个计数器记录着该对象被使用的次数</p>
</li>
<li>
<p>可以立即回收垃圾。因为每个对象在被引用次数为0的时候，是立即就可以知道的。</p>
</li>
<li>
<p>没有暂停时间。这个很容易理解，对象的回收根本不需要另外的GC线程专门去做，业务线程自己就搞定了。</p>
</li>
<li>
<p>不需要stop the world，当然，在多线程的情况下，必要的同步和互斥操作还是需要的。</p>
</li>
<li>
<p>一个致命缺陷是循环引用，就是， objA引用了objB，objB也引用了objA。这种情况下，这两个对象是不能被回收的。
<img src="doc/demo02_base/image/cycle.JPG" alt="Image text" /></p>
</li>
<li>
<p>可以使用unreference去释放引用计数的对象</p>
</li>
<li>
<p>引用计数既保留了性能，也保证了更加高效的性能
<img src="doc/demo02_base/image/%E5%A4%AA%E6%9E%81.png" alt="Image text" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-场景树"><a class="header" href="#1-场景树">1. 场景树</a></h1>
<ul>
<li>Nodes（节点）是在Godot中创建游戏的基本构建块。当一组节点被添加到树中时，它被称为sence（场景），树被称为sence tree（场景树）</li>
</ul>
<pre><code>节点是可以表示各种专用游戏功能的对象。给定类型的节点可以显示图形，播放动画或表示对象的3D模型。
该节点还包含一组属性，允许你自定义其行为。
你添加到项目中的节点取决于你需要的功能。
它是一个模块化系统，旨在为你提供构建游戏对象的灵活性。

在项目中，你添加的节点将组织为树结构。在树中，节点被添加为其他节点的子节点。
特定节点可以具有任意数量的子节点，但只能有一个父节点。
</code></pre>
<p><img src="doc/demo03_lifecycle/image/scene-tree.png" alt="Image text" /></p>
<h1 id="2-帧率"><a class="header" href="#2-帧率">2. 帧率</a></h1>
<ul>
<li>帧率 Framerate ，指画面每秒更新多少次 (FPS, Frames Per Second)</li>
</ul>
<pre><code>比如，
  FPS = 50 , 即每 20ms 秒更新一次
  FPS = 60,  约 16.7ms 秒更新一次

通过代码可以设置，要求 godot 引擎尽量以此帧率运行 ，但实际帧率还是会有偏差
Engine.target_fps = 120
</code></pre>
<p><img src="doc/demo03_lifecycle/image/%E5%9C%BA%E6%99%AF%E5%BE%AA%E7%8E%AF.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/%E5%9C%BA%E6%99%AF%E5%B8%A7.png" alt="Image text" /></p>
<ul>
<li>delta time上一帧的间隔</li>
</ul>
<pre><code>匀速移动的优化：
 var step = 0.8f * deltaTime;
其中，
   0.8f  表示每秒位移 0.8 单位
</code></pre>
<p><img src="doc/demo03_lifecycle/image/delta.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/delta-1.png" alt="Image text" /></p>
<h1 id="3-节点的生命周期"><a class="header" href="#3-节点的生命周期">3. 节点的生命周期</a></h1>
<ul>
<li>在Godot中，一个游戏的启动大致流程如下：</li>
</ul>
<pre><code>Godot的main启动一个进程，加载所需的驱动设备（如渲染设备：GL/GLES/Vulkan等）、音频设备，输入控制器设备等等；

然后进入主循环，加载一个自动创建的对象——SceneTree（场景管理系统对象，它用户管理场景图），
这个对象包含一个RootViewPort节点（它是一个Node），该节点包含一个默认的ViewPort（以便提供默认渲染的输出视口）。

当用户用Godot编辑器创建一个关卡（或场景文件），并设置默认的启动的场景文件，Godot将该场景文件的根节点附加到RootViewPort节点上，
当节点进入场景树（SceneTree），变为活动状态。
按场景树顺序依次回调各个子节点的_init()，_ready()等声明函数。
</code></pre>
<p><img src="doc/demo03_lifecycle/image/godot_process.jpg" alt="Image text" />
<img src="doc/demo03_lifecycle/image/godot_node.jpg" alt="Image text" />
<img src="doc/demo03_lifecycle/image/godot_lifecycle.jpg" alt="Image text" /></p>
<h1 id="4-节点的获取方式"><a class="header" href="#4-节点的获取方式">4. 节点的获取方式</a></h1>
<pre><code># 获取当前节点
var currentNode1 = $&quot;.&quot;
var currentNode2 = self

# 获取父节点
var parentNode1 = get_parent()
var parentNode2 = $&quot;../&quot;

# 获取子节点
var subNode1 = $SubNode2
var subNode2 = $&quot;SubNode2&quot;
var subNode3 = get_node(&quot;SubNode2&quot;)

# 根节点查找法，会返回节点树从上到下找到的第一个节点
var subNode4 = get_tree().root.find_node(&quot;SubNode2&quot;, true, false)
</code></pre>
<h1 id="5-process和physics_process"><a class="header" href="#5-process和physics_process">5. process和physics_process</a></h1>
<ul>
<li>平时我们看到的动画，实际上是由很多静止的画面连续切换组成的</li>
<li>其中每个静止的画面，我们都称为一帧，比如60帧的动画，就是一秒播放60个静止的画面，组成的动画</li>
<li>godot 的 _process 相当于 unity 的 Update</li>
</ul>
<pre><code>内部对代码就会在每一帧之前被执行，也就是引擎每渲染一幅的画面之前，都会执行它里面的代码
</code></pre>
<ul>
<li>godot 的 _physics_process 相当于 unity 的 FixedUpdate</li>
</ul>
<pre><code>内部的代码会在每个物理帧之前被执行，
因为godot的物理模拟是单独进行的，每次进行物理模拟的时候，如计算一个刚体小球的运动轨迹，每进行一次计算，我们就称为是一进行了一个物理帧，
而每次进行物理模拟之前，都会执行_physics_process中的代码
</code></pre>
<p><img src="doc/demo03_lifecycle/image/process.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/process-1.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/physics.png" alt="Image text" />
<img src="doc/demo03_lifecycle/image/physics-1.png" alt="Image text" /></p>
<h1 id="6-parent和owner"><a class="header" href="#6-parent和owner">6. Parent和Owner</a></h1>
<ul>
<li>
<p>Parent</p>
<ul>
<li>一个节点的Parent就是场景树上它的父级</li>
</ul>
</li>
<li>
<p>Owner</p>
<ul>
<li>如果不修改默认Owner的话，可以把它视为节点所在场景的顶部节点，如果该节点本身就是顶部节点那么它的Owner为null</li>
</ul>
</li>
<li>
<p>静态场景结构中默认的Owner</p>
</li>
</ul>
<p><img src="doc/demo03_lifecycle/image/owner01.png" alt="Image text" /></p>
<pre><code>extends Node

class_name TestNode

func _ready():
	var parent_name = &quot;NULL&quot;
	var owner_name = &quot;NULL&quot;
	if get_parent() != null:
		parent_name = get_parent().name
	if owner != null:
		owner_name = owner.name
	print(name + &quot;'s parent is &lt;&quot; + parent_name + &quot;&gt; and it's owner is &lt;&quot; + owner_name + &quot;&gt;&quot; )
	
</code></pre>
<pre><code>node_3's parent is &lt;node_2&gt; and it's owner is &lt;node_0&gt;
node_2's parent is &lt;node_1&gt; and it's owner is &lt;node_0&gt;
node_1's parent is &lt;node_0&gt; and it's owner is &lt;node_0&gt;
node_0's parent is &lt;root&gt; and it's owner is &lt;NULL&gt;
</code></pre>
<ul>
<li>动态创建的节点的Owner是null</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-信号signal"><a class="header" href="#1-信号signal">1. 信号signal</a></h1>
<ul>
<li>
<p>信号是用来完成模块或功能之间通信的媒介，其实就是约定了一些方法的回调形式</p>
</li>
<li>
<p>设计模式上叫做观察者设计模式</p>
</li>
</ul>
<pre><code>1. 观察者和被观察者是抽象耦合的，解耦模块 
2. 建立一套统一的触发机制
</code></pre>
<ul>
<li>
<p>Godot引擎官方建议在你的游戏开发中更多的使用信号来完成模块或功能间的通信</p>
</li>
<li>
<p>第一种使用方法</p>
</li>
</ul>
<pre><code># 第一种信号接受方法，通过在场景中配置信号的接收方法
func _on_Button1_pressed():
	print(&quot;hello button1&quot;)
</code></pre>
<ul>
<li>第二种使用方法</li>
</ul>
<pre><code># 第二种信号接受方法，通过代码控制信号的接收，更加的灵活，比较推荐方式
func _ready():
	$Button2.connect(&quot;pressed&quot;, self, &quot;onButton2&quot;)
	
func onButton2():
	print(&quot;button2 pressed&quot;)
</code></pre>
<h1 id="2-自定义信号"><a class="header" href="#2-自定义信号">2. 自定义信号</a></h1>
<ul>
<li>自定义信号</li>
</ul>
<pre><code>signal mySignal(a, b)
</code></pre>
<ul>
<li>发送信号</li>
</ul>
<pre><code>emit_signal(&quot;mySignal&quot;, 1, 2)
</code></pre>
<ul>
<li>解除绑定信号</li>
</ul>
<pre><code>disconnect(&quot;mySignal&quot;, 1, 2)
</code></pre>
<h1 id="3-异步回调yield"><a class="header" href="#3-异步回调yield">3. 异步回调yield</a></h1>
<ul>
<li>yield, to produce a result, answer, or piece of information，立即结束当前函数调用，无需等待</li>
</ul>
<pre><code>其本质，就是能让一个函数在执行过程中暂停（挂起），然后在接收到恢复指令以后继续执行的机制。
</code></pre>
<ul>
<li>yield(obj, signal)，函数立即返回，并且保存当前执行的位置和状态</li>
</ul>
<pre><code>GDScriptFunctionState yield( Object object=null, String signal=&quot;&quot; )
</code></pre>
<ul>
<li>yield返回GDScriptFunctionState类型对象，类似于Java的CompleteFuture</li>
</ul>
<pre><code>GDScriptFunctionState 是记录一个协程状态的对象，实际上它就代表(引用)着该协程。
</code></pre>
<ul>
<li>resume恢复GDScriptFunctionState保存的调用函数状态</li>
</ul>
<p><img src="doc/demo04_signal/image/yield.JPG" alt="Image text" /></p>
<ul>
<li>yield的三种用法</li>
</ul>
<ol>
<li>yield()和resmue()组合，yield()来挂起，用resmue()来恢复</li>
<li>yield(对象,信号S)的形式，把这个协程（即 GDScriptFunctionState）注册为 节点N上信号S的接收者，当 节点N发出信号S以后，函数会恢复执行。</li>
<li>yield(协程对象C,&quot;completed&quot;)的形式，协程失效（即GDScriptFunctionState的is_valid为false）以后，它会释放一个&quot;completed&quot;信号，用这个信号恢复上一层协程。</li>
</ol>
<h1 id="4-多线程"><a class="header" href="#4-多线程">4. 多线程</a></h1>
<ul>
<li>什么是进程？</li>
</ul>
<pre><code>电脑中有时会有很多单独运行的程序，每个程序有一个独立的进程，而进程之间是相互独立存在的。比如QQ、浏览器
</code></pre>
<ul>
<li>什么是线程？</li>
</ul>
<pre><code>进程想要执行任务就需要依赖线程。换句话说，就是进程中的最小执行单位就是线程，并且一个进程中至少有一个线程。
</code></pre>
<ul>
<li>那什么是多线程？提到多线程这里要说两个概念，就是串行和并行，搞清楚这个，我们才能更好地理解多线程。</li>
<li>串行，其实是相对于单条线程来执行多个任务来说的，比如下载一个文件要等到上一个文件下载完</li>
<li>并行，下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的，在同一时刻发生的，并行在时间上是重叠的</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-屏幕坐标"><a class="header" href="#1-屏幕坐标">1. 屏幕坐标</a></h1>
<p><img src="doc/demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt="Image text" />
<img src="doc/demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB-godot-1.png" alt="Image text" />
<img src="doc/demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB-godot-4%E4%B8%AA%E8%B1%A1%E9%99%90.png" alt="Image text" /></p>
<ul>
<li>刚开始学习的时候可能有点疑惑，godot的坐标系，原点既然在左上角</li>
<li>unity，cocos的2d原点都在左下角，就很符合数学里面的象限，左下角的2d坐标系感觉很复合习惯</li>
</ul>
<pre><code>后来了解到，计算机屏幕是从左上角开始刷新的，2d坐标系左上角为原点可以屏幕坐标系吻合可以提升一点效率。  

unity的2d坐标系虽然在左下角，但是unity的屏幕坐标系依然在左上角，不统一。
虽然godot的2d坐标系在左上角的坐标系刚开始看不舒服，但是和屏幕坐标系吻合了，也算一种统一，就不需要untiy2d的那么多概念了，为godot点赞。

因为单论平面内容制作，左上原点更符合视觉习惯，也更符合设计常识，比如ps。
</code></pre>
<p><img src="doc/demo05_scene_node/image/%E5%9D%90%E6%A0%87%E7%B3%BB-ps.JPG" alt="Image text" /></p>
<ul>
<li>
<p>世界坐标系：又称为全局坐标系，以场景树的root节点为坐标系原点</p>
</li>
<li>
<p>相对坐标系：又称为局部坐标系或者本地坐标系，相对于父节点的坐标，godot的坐标都是相对坐标</p>
</li>
<li>
<p>屏幕坐标：屏幕的左上角为坐标系原点</p>
</li>
<li>
<p>屏幕分辨率，屏幕分辨率是指纵横向上的像素点数，单位是px，4:3 是最常见屏幕比例
<img src="doc/demo05_scene_node/image/pixel.jpg" alt="Image text" /></p>
</li>
<li>
<p>屏幕像素和图片像素有什么关系</p>
</li>
</ul>
<pre><code>在屏幕显示图片时，如果屏幕的长宽比、像素数和图片一致，只需要每个屏幕像素用子像素的敏感组合表示出图片上的像素就可以了。
那如果图片像素数和屏幕像素数不一样呢？

当图片像素大于屏幕像素时，屏幕也是进行合并显示的。
比如一张1200W像素的图片，要在300W像素的显示器（长宽比一致）上显示，那么系统就需要将图片像素进行四合一计算然后再显示。
当图片像素数大于屏幕像素数时，高像素图片和低像素图片的显示精细度是一样的！
</code></pre>
<ul>
<li>在godot中，一般position的1个单位长度等于1个图片像素</li>
</ul>
<h1 id="2-全局和相对坐标的相互转化"><a class="header" href="#2-全局和相对坐标的相互转化">2. 全局和相对坐标的相互转化</a></h1>
<ul>
<li>全局坐标和局部坐标（相对坐标）可以相互转化</li>
</ul>
<pre><code>Node2D及其子节点的位置可以使用position和gloabl_position来控制。
其中，前者是该节点相对于父节点的相对位置，后者是全局位置。

简而言之，position的坐标系是以父节点的位置坐标为原点的坐标系，方向，还是水平向右为x轴正方向，竖直向下为y轴正方向。
需要注意的是，全局位置是以场景的左上角为原点的，并不是以根结点的位置作为原点的
</code></pre>
<h1 id="3-场景和节点"><a class="header" href="#3-场景和节点">3. 场景和节点</a></h1>
<p><img src="doc/demo05_scene_node/image/%E5%9C%BA%E6%99%AF.png" alt="Image text" />
<img src="doc/demo05_scene_node/image/%E8%8A%82%E7%82%B9.png" alt="Image text" />
<img src="doc/demo05_scene_node/image/%E8%8A%82%E7%82%B9%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F.png" alt="Image text" />
<img src="doc/demo05_scene_node/image/%E8%8A%82%E7%82%B9%E7%9A%84%E9%A1%BA%E5%BA%8F.png" alt="Image text" /></p>
<ul>
<li>一个游戏可以包含多个场景，但是一个场景中必须有一个根节点，一个根节点可以包含多个不重名的子节点（unity的子节点可以同名），不同名更加符合习惯，为godot点赞。</li>
</ul>
<h1 id="4-基本组件"><a class="header" href="#4-基本组件">4. 基本组件</a></h1>
<ul>
<li>
<p>CanvasItem节点，CanvasItem -&gt; Node -&gt; Object</p>
</li>
<li>
<p>Canvas是画布的意思，所以CanvasItem代表了就是可以被绘制节点，可以设置可视化界面和材质的颜色</p>
</li>
<li>
<p>所有的2D节点和GUI节点都继承于CanvasItem节点
<img src="doc/demo05_scene_node/./image/component1.png" alt="Image text" /></p>
</li>
<li>
<p>Sprite节点，Node2d -&gt; CanvasItem -&gt; Node -&gt; Object</p>
</li>
<li>
<p>用来显示一张图片
<img src="doc/demo05_scene_node/./image/component2.png" alt="Image text" /></p>
</li>
<li>
<p>Texture类，Resource -&gt; Reference -&gt; Object</p>
</li>
<li>
<p>Texture 贴图，附加到物体表面的贴图，实际上就是包含一张Image图片</p>
</li>
<li>
<p>可以用在3D模型中当作贴图，或者2D的Sprite中当作图片，或者GUI的背景
<img src="doc/demo05_scene_node/./image/component3.png" alt="Image text" /></p>
</li>
<li>
<p>Image类，Resource -&gt; Reference -&gt; Object</p>
</li>
<li>
<p>包含了图片的数
<img src="doc/demo05_scene_node/./image/component4.png" alt="Image text" /></p>
</li>
<li>
<p>总结
<img src="doc/demo05_scene_node/./image/component5.png" alt="Image text" /></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><img src="doc/demo06_move/image/move1.png" alt="Image text" />
<img src="doc/demo06_move/image/move2.png" alt="Image text" />
<img src="doc/demo06_move/image/move3.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="doc/demo07_collision/image/collision-1.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-2.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-3.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-4.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-5.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-6.png" alt="Image text" />
<img src="doc/demo07_collision/image/collision-8.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组件的使用"><a class="header" href="#组件的使用">组件的使用</a></h1>
<ul>
<li>Path2D</li>
</ul>
<pre><code>Contains a Curve2D path for PathFollow2D nodes to follow，Describes a Bézier curve in 2D space.
</code></pre>
<ul>
<li>PathFollow2D</li>
</ul>
<pre><code>This node takes its parent Path2D, and returns the coordinates of a point within it, given a distance from the first vertex.


It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be children of this node.
The descendant nodes will then move accordingly when setting an offset in this node.
</code></pre>
<ul>
<li>RemoteTransform2D，类似与设计模式中的代理模式</li>
</ul>
<pre><code>RemoteTransform2D pushes its own Transform2D to another CanvasItem derived Node in the scene.

It can be set to update another Node's position, rotation and/or scale. It can use either global or local coordinates.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="doc/demo09_canvas/image/canvas1.png" alt="Image text" />
<img src="doc/demo09_canvas/image/canvas2.png" alt="Image text" />
<img src="doc/demo09_canvas/image/canvas3.png" alt="Image text" />
<img src="doc/demo09_canvas/image/canvas4.png" alt="Image text" />
<img src="doc/demo09_canvas/image/canvas5.png" alt="Image text" />
<img src="doc/demo09_canvas/image/canvas6.png" alt="Image text" />
<img src="doc/demo09_canvas/image/canvas7.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>sprite</li>
</ul>
<pre><code>上世纪70年代，在德州电器公司，一个叫Daniel Hillis的前辈最早把Sprite这个词用在计算机图形上，在展示界面上，
有一些东西在实现层面并不是和整个画面融为一体的，而是『漂浮』在其他画面之上，像『幽灵』一样，所以被称为Sprite。

一张一张的图片组成了一个会动的精灵
</code></pre>
<p><img src="doc/demo10_animation/image/animation1.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation2.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation3.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation4.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation5.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation6.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation7.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation8.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation9.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation10.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation11.png" alt="Image text" />
<img src="doc/demo10_animation/image/animation12.png" alt="Image text" /></p>
<ul>
<li>AnimationPlayer是时间和属性的变化，是一种动画的表现</li>
<li>AnimatedSprite是序列帧的简便的用法</li>
</ul>
<p><img src="doc/demo10_animation/image/animated1.png" alt="Image text" />
<img src="doc/demo10_animation/image/animated2.png" alt="Image text" />
<img src="doc/demo10_animation/image/animated3.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="doc/demo11_particle_light/image/particle1.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle2.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle3.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle4.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle5.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle6.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle7.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle8.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle9.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle10.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle11.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle12.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle13.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle14.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle15.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle16.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle17.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle18.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle19.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle20.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle21.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle22.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle23.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle24.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle25.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle26.png" alt="Image text" />
<img src="doc/demo11_particle_light/image/particle27.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>godot默认不显示中文，需要下载中文的字体</li>
<li>字体，https://github.com/adobe-fonts/source-han-sans/releases</li>
</ul>
<pre><code>思源黑体
由Google和Adobe在2014年7月正式推出的开源字体不仅可以免费商用而且全面支持中文简体、中文繁体（香港）、中文繁体（台湾）、日文和韩文，还有七种字体粗细，整个字形个数接近50万。

免费可商用
</code></pre>
<h1 id="controller"><a class="header" href="#controller">controller</a></h1>
<p><img src="doc/demo12_gui/image/gui1.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui2.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui3.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui4.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui5.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui6.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui7.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui8.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui9.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui10.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui11.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui12.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui13.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui14.png" alt="Image text" />
<img src="doc/demo12_gui/image/gui15.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="camera"><a class="header" href="#camera">camera</a></h1>
<p><img src="doc/demo13_camera/image/camera1.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera2.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera3.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera4.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera5.png" alt="Image text" />
<img src="doc/demo13_camera/image/camera6.png" alt="Image text" /></p>
<h1 id="viewport视口可视化窗口"><a class="header" href="#viewport视口可视化窗口">viewport(视口，可视化窗口)</a></h1>
<ul>
<li>root就是根节点的viewport
<img src="doc/demo13_camera/image/viewport1.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport2.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport3.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport4.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport5.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport6.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport7.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport8.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport9.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport10.png" alt="Image text" />
<img src="doc/demo13_camera/image/viewport11.png" alt="Image text" /></li>
</ul>
<h1 id="canvas-layer"><a class="header" href="#canvas-layer">canvas layer</a></h1>
<ul>
<li>它是一个节点, 为所有子代和孙代添加一个单独的2D渲染层.Viewport的子节点默认在图层 &quot;0 &quot; 处绘制, 而CanvasLayer将在任何数字层处绘制.</li>
<li>数字较大的图层将绘制在数字较小的图层之上.CanvasLayers也有自己的变换, 不依赖于其他层的变换. 这使得当我们对游戏世界的观察发生变化时,UI可以固定在屏幕空间中.</li>
</ul>
<p><img src="doc/demo13_camera/image/canvaslayers.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file文件系统"><a class="header" href="#file文件系统">file文件系统</a></h1>
<p><img src="doc/demo14_file/image/file1.png" alt="Image text" />
<img src="doc/demo14_file/image/file2.png" alt="Image text" />
<img src="doc/demo14_file/image/file3.png" alt="Image text" />
<img src="doc/demo14_file/image/file4.png" alt="Image text" />
<img src="doc/demo14_file/image/file5.png" alt="Image text" />
<img src="doc/demo14_file/image/file6.png" alt="Image text" />
<img src="doc/demo14_file/image/file7.png" alt="Image text" /></p>
<h1 id="autoload单例模式"><a class="header" href="#autoload单例模式">autoload单例模式</a></h1>
<p><img src="doc/demo14_file/image/autoload1.png" alt="Image text" />
<img src="doc/demo14_file/image/autoload2.png" alt="Image text" />
<img src="doc/demo14_file/image/autoload3.png" alt="Image text" />
<img src="doc/demo14_file/image/autoload4.png" alt="Image text" />
<img src="doc/demo14_file/image/autoload5.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="doc/demo15_audio/image/audio1.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio2.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio3.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio4.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio5.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio6.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio7.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio8.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio9.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio10.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio11.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio12.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio13.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio14.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio15.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio16.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio17.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio18.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio19.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio21.png" alt="Image text" />
<img src="doc/demo15_audio/image/audio22.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="doc/demo16_http/image/http1.png" alt="Image text" />
<img src="doc/demo16_http/image/http2.png" alt="Image text" />
<img src="doc/demo16_http/image/http3.png" alt="Image text" />
<img src="doc/demo16_http/image/http4.png" alt="Image text" />
<img src="doc/demo16_http/image/http5.png" alt="Image text" />
<img src="doc/demo16_http/image/http6.png" alt="Image text" />
<img src="doc/demo16_http/image/http7.png" alt="Image text" />
<img src="doc/demo16_http/image/http8.png" alt="Image text" />
<img src="doc/demo16_http/image/http9.png" alt="Image text" />
<img src="doc/demo16_http/image/http10.png" alt="Image text" />
<img src="doc/demo16_http/image/http11.png" alt="Image text" />
<img src="doc/demo16_http/image/http12.png" alt="Image text" />
<img src="doc/demo16_http/image/http13.png" alt="Image text" />
<img src="doc/demo16_http/image/http14.png" alt="Image text" />
<img src="doc/demo16_http/image/http15.png" alt="Image text" />
<img src="doc/demo16_http/image/http16.png" alt="Image text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一设计模式六大原则"><a class="header" href="#一设计模式六大原则">一、设计模式六大原则</a></h1>
<ul>
<li>1.单一职责原则</li>
</ul>
<pre><code>一个类只负责一项职责。 
</code></pre>
<ul>
<li>2.里氏替换原则</li>
</ul>
<pre><code>所有引用父类的地方必须能透明地使用其子类的对象。

继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。
比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，
如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。

里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：
子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
子类中可以增加自己特有的方法。
</code></pre>
<ul>
<li>3.依赖倒置原则</li>
</ul>
<pre><code>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。
</code></pre>
<ul>
<li>4.接口隔离原则</li>
</ul>
<pre><code>一个类对另一个类的依赖应该建立在最小的接口上。 
接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。
</code></pre>
<ul>
<li>5.迪米特法则</li>
</ul>
<pre><code>迪米特法则又叫最少知道原则，一个对象应该对其他对象保持最少的了解。
</code></pre>
<ul>
<li>6.开闭原则</li>
</ul>
<pre><code>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
</code></pre>
<h1 id="二23种设计模式"><a class="header" href="#二23种设计模式">二、23种设计模式</a></h1>
<h2 id="1创建型模式"><a class="header" href="#1创建型模式">1.创建型模式</a></h2>
<ol>
<li>简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</li>
<li>工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。</li>
<li>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。</li>
<li>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。如StringBuilder的append()</li>
<li>单例模式：饿汉式，懒汉式，双重检测，静态内部类，枚举类实现具有天然的线程安全并且避免反射和反序列化漏洞</li>
<li>原型模式：prototype，通过复制现有的实例来创建新的实例。如深克隆，浅克隆</li>
</ol>
<h2 id="2结构型模式"><a class="header" href="#2结构型模式">2.结构型模式</a></h2>
<ol>
<li>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。如各种Adapter</li>
<li>组合模式：将对象组合成树形结构以表示的层次结构。可以理解成组合，如窗体控件，一个下滑的窗口中包含的List</li>
<li>装饰模式：动态的给对象添加新的功能。如Java的IO流</li>
<li>代理模式：为其他对象提供一个代理以便控制这个对象的访问。如静态代理，动态代理javaassist</li>
<li>亨元模式：通过共享技术来有效的支持大量细粒度的对象。</li>
<li>外观模式：facade，对外提供一个统一的方法，来访问子系统中的一群接口。</li>
<li>桥接模式：将抽象部分和它的实现部分分离，取代多层继承，多层继承违反单一职责。如DriverManager -- JDBC驱动 -- (MySQL Oracle)</li>
</ol>
<h2 id="3行为型模式"><a class="header" href="#3行为型模式">3.行为型模式</a></h2>
<ol>
<li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</li>
<li>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。如Spring的expression</li>
<li>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</li>
<li>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</li>
<li>观察者模式：对象间的一对多的依赖关系。</li>
<li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态，以便提供一个可回滚的操作。</li>
<li>中介者模式：用一个中介对象来封装一系列的对象交互。如java反射method.invoke()</li>
<li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。如执行sql语句</li>
<li>访问者模式：对于存储再一个集合中的对象，它们可能具有不同的类型，不同的访问者，其访问方式不同。</li>
<li>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</li>
<li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。如Iterator接口</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
